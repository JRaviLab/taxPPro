---
title: "Stats"
format: html
editor: visual
---

All of the values here are after filtering the bugphyzz data with
`taxPPro::filterData`.

Load packages:

```{r, message=FALSE}
library(taxPPro)
library(bugphyzz)
library(bugphyzzExports)
library(purrr)
library(dplyr)
library(ggplot2)
library(tidyr)
library(data.tree)
```

Import data:

```{r, message=FALSE, warning=FALSE}
bugphyzz_data <- physiologies()
```


Convert numeric data to categorical:

```{r, message=FALSE}
phys <- vector('list', length(bugphyzz_data))
for (i in seq_along(phys)) {
    at <- unique(bugphyzz_data[[i]]$Attribute_type)
    dat_name <- names(bugphyzz_data)[i]
    names(phys)[i] <- dat_name
    if (at == 'range' && dat_name %in% names(THRESHOLDS())) {
        msg <- paste0(
            dat_name, " is of type range and we have a threshold for it.",
            ' Converting ', dat_name, ' to multistate-intersection.'
        )
        message(msg)
        res <- rangeToLogicalThr(bugphyzz_data[[i]], THRESHOLDS()[[dat_name]])
        res$Attribute_type <- 'multistate-intersection'
        phys[[i]] <- res

    } else if (at == 'range' && !dat_name %in% names(THRESHOLDS())) {
        msg <- paste0(
            dat_name, " is of type range, but we don't have a threshold for it.",
            " Skipping ", dat_name, '.'
        )
        message(msg)
        next

    } else {
        phys[[i]] <- bugphyzz_data[[i]]

    }
}
phys <- discard(phys, is.null)
## halophily is lost during this process
```

Filter data:

```{r, message=FALSE}
filtered_data <- map(phys, filterData) |> 
    discard(~ !nrow(.x))
```

## Taxa with NCBI ID and taxa without NCBI ID

```{r}
has_id_counts <- map(filtered_data, ~ {
    .x |> 
        mutate(NCBI_ID = stringr::str_squish(tolower(as.character(NCBI_ID)))) |> 
        mutate(
            has_id = case_when(
                is.na(NCBI_ID) | NCBI_ID == 'unknown' ~ "no_id",
                grepl('\\d+', NCBI_ID) ~ 'has_id',
                TRUE ~ NCBI_ID
            )
        ) |> 
        count(has_id)
}) |> 
    bind_rows(.id = 'physiology')
```

```{r}
has_id_counts |> 
    # arrange(n, has_id) |> 
    # mutate(physiology = forcats::fct_inorder(physiology)) |> 
    ggplot() +
    geom_col(
        aes(physiology, n, fill = has_id),
        position = position_fill()
    ) +
    labs(y = '%') +
    theme_bw() +
    theme(
        axis.text.x = element_text(angle = 45, hjust = 1)
    )
```

Prepare data for propagation

```{r, message=FALSE, warning=FALSE}
myData <- map(filtered_data, getDataReady)
data_ready <- map(myData, bind_rows)
data_ready <- discard(data_ready, ~ !nrow(.x))
```

Let's check it there was actually an increase of taxa after pooling
the taxa without IDs to the taxa with IDs.

```{r}
taxids_before <- map_int(filtered_data, ~ {
    .x |> 
        filter(grepl('^\\d+$', NCBI_ID)) |> 
        pull(NCBI_ID) |> 
        unique() |> 
        length()
})
taxids_after <- map_int(data_ready, ~ length(unique(pull(.x, NCBI_ID))))
taxids_before <- taxids_before[names(taxids_after)]
taxids_counts <- data.frame(
    when = c(rep('before', length(taxids_before)), rep('after', length(taxids_after))),
    physiology = c(names(taxids_before), names(taxids_after)),
    n = c(taxids_before, taxids_after)
)
```


Plot before and after:

```{r}
taxids_counts |> 
    mutate(when = factor(when, levels = c('before', 'after'))) |> 
    ggplot() + 
    geom_col(
        aes(physiology, n, fill = when),
        position = position_dodge(0.9)
    ) +
    theme_bw() +
    scale_fill_manual(
        values = c('dodgerblue3', 'firebrick3')
    ) +
    theme(
        axis.text.x = element_text(angle = 45, hjust = 1)
    )
```



```{r}
taxids_increment <- taxids_counts |> 
    pivot_wider(
        names_from = 'when', values_from = 'n'
    ) |> 
    mutate(increment = after / before)
```

```{r}
taxids_increment |> 
    ggplot() +
    geom_col(
        aes(reorder(physiology, -increment), increment),
        color = 'grey30', fill = 'gray90'
    ) +
    geom_hline(yintercept = 1, color = 'red') +
    theme_bw() +
    theme(
        axis.text.x = element_text(angle = 45, hjust = 1)
    )
```


Convert data.farmes into matrices:

```{r}
my_data <- list_flatten(myData) |> 
    discard(is.null)
my_data_mat <- map(my_data, ~ {
    .x |>
        select(NCBI_ID, Attribute, Score) |> 
        pivot_wider(
            names_from = Attribute, values_from = Score
        ) |> 
        tibble::column_to_rownames(var = 'NCBI_ID') |> 
        as.data.frame() |> 
        as.matrix()
})
```


How many double annotations:


```{r}
dbl <- map(my_data_mat, ~ {
    v <- rowSums(.x > 0)
    v <- v[v > 1]
    names(v)
}) |> 
    discard(~ !length(.x))
``` 

```{r}
dbl_counts <- dbl |> 
    map_int(~ length(.x)) |> 
    as.data.frame() |> 
    tibble::rownames_to_column(var = 'physiology') |> 
    set_names(c('physiology', 'n_dbl_annotations'))
```

```{r}
dbl_counts |> 
    ggplot() +
    geom_col(aes(reorder(physiology, -n_dbl_annotations), n_dbl_annotations)) +
    theme_bw() +
    theme(
        axis.text.x = element_text(angle = 45, hjust = 1)
    )
```


```{r}  ``` 


Import tree (ncbi and ltp)

Phylo tree (LTP)

```{r}
ltp <- ltp()
ltp_tip_data <- ltp$tip_data
```

Number of taxa with double annotations that are also in the 
ltp tree:

```{r}
dbl_in_ltp <- map_int(dbl, ~ sum(.x %in% ltp_tip_data$NCBI_ID)) |> 
    as.data.frame() |> 
    tibble::rownames_to_column(var = 'physiology') |> 
    set_names(c('physiology', 'n')) |> 
    filter(n > 0)
```


## Completeness of the different trees

```{r}

```













