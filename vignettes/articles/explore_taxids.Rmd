---
title: "Explore taxid data"
output:
    html_document:
        toc: true
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, message=FALSE, warning=FALSE}
library(taxPPro)
library(purrr)
library(dplyr)
library(bugphyzz)
library(tidyr)
# taxizedb::db_download_ncbi(verbose = TRUE, overwrite = TRUE)
```

# NCBI sets

We need a set of taxa in the NCBI to 1) use as a reference to calculate
completeness and 2) to create a tree data structure for propagation.

The sets are based on the options given at the NCBI taxonomy statistics page:
[NCBI Taxonomy Statistics page](https://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=statistics&unclassified=hide&uncultured=hide&period=&from=&to=).

For convenience these sets were downloaded and included in the extdata
directory of the current package (`taxPPro`):

```{r import sets of taxids}
my_ranks <- c('genus', 'species', 'strain')
dir <- system.file('extdata', package = 'taxPPro')
fnames <- list.files(dir, pattern = 'proc.*.txt', full.names = TRUE)
taxids_ls <- vector('list', length(fnames))
for (i in seq_along(taxids_ls)) {
  taxids <- read.table(fnames[i], header = FALSE)[[1]]
  names(taxids_ls)[i] <- sub('^.*/proc_(.*)_[0-9]*\\.txt', '\\1', fnames[i])
  ranks <- taxizedb::taxid2rank(taxids, db = 'ncbi')
  taxids_ls[[i]] <-  data.frame(taxid = taxids, rank = ranks) |> 
    filter(rank %in% my_ranks) 
}
taxids_summary <- taxids_ls |> 
  bind_rows(.id = 'set') |> 
  count(set, rank) |> 
  pivot_wider(
    names_from = rank, values_from = n, values_fill = 0
  ) |> 
  mutate(total = genus + species + strain) |> 
  arrange(total, set)
DT::datatable(
  taxids_summary, 
  caption = 'Table 1. Number of taxa per rank and NCBI set.'
)
```

# Percentage of bugphyzz taxids annotated in the NCBI:

Get a nested list of the sets of NCBI taxids:

```{r}
taxids_ls2 <- taxids_ls |> 
  map(~ split(.x, factor(.x$rank))) |> 
  map_depth(.depth = 2, .f = ~.x$taxid)
str(taxids_ls2, max.level = 2, vec.len = 1)
```

Import bugphyzz physiologies:

```{r, message=FALSE}
phys <- physiologies(remove_false = TRUE, full_source = FALSE)
```

Create a list of bugphyzz taxids:

```{r}
bp_ids <- phys |> 
  map(~ pull(filter(.x, NCBI_ID != 'unknown'), NCBI_ID)) |> 
  unlist(use.names = FALSE, recursive = TRUE) |> 
  unique()
bp_ranks <- taxizedb::taxid2rank(bp_ids, db = 'ncbi')
bp_df <- data.frame(taxid = bp_ids, rank = bp_ranks) |> 
  filter(!is.na(bp_ranks))
bp_ids_ls <- split(bp_df, factor(bp_df$rank)) |> 
  {\(y) map(y, ~ .x[[1]])}() |> 
  {\(y) y[my_ranks]}()
str(bp_ids_ls, vec.len = 1)
```

Calculate percentage of bugphyzz taxa in every NCBI set:

```{r}
myFun <- function(taxids_var) {
  names(taxids_var)
  bp_subset <- bp_ids_ls[names(taxids_var)]
  per <- map2_dbl(bp_subset, taxids_var, ~ round(mean(.x %in% .y) * 100))
  data.frame(per) |> 
    tibble::rownames_to_column(var = 'rank')
}
bp_ids_summary <- map(taxids_ls2, myFun) |> 
  bind_rows(.id = 'set') |> 
  pivot_wider(names_from = 'rank', values_from = 'per', values_fill = 0) |> 
  left_join(taxids_summary[,c('set', 'total')], by = 'set') |> 
  arrange(total, set)
DT::datatable(
  bp_ids_summary,
  caption = 'Table 2. Percentage of bugphyzz taxa also annotated in the NCBI sets per rank.'
)
```
# Creating a data.tree stucture based on strains using the exclude unclassified and uncultured set

We could create a data.tree structure using the strains, but the number of
species is less. Maybe, because not all of the species have strains in the
NCBI.

All of the species with strains are represented in all of the NCBI sets:

```{r}
uu_strains <- taxids_ls2$exclude_unclassified_uncultured$strain
uu_strains_class <- taxizedb::classification(uu_strains, db = 'ncbi')
uu_strains_tbl <- map(uu_strains_class, classif2Table) |> 
  bind_rows()
uu_strains_sp <- unique(uu_strains_tbl$species)
map(taxids_ls2, ~ round(mean(uu_strains_sp %in% .x$species) * 100))
```

But not the other way around. Species in the different NCBI sets would not 
be fully represented in a tree constucted based on strains:

```{r}
map(taxids_ls2, ~ round(mean(.x$species %in% uu_strains_sp) * 100))
## the percentage of include_all is so low because it includes so many more
## species
```
# Create a tree based on species using the exlude_all set


```{r}
exall_sp <- taxids_ls2$exclude_all$species
exall_sp_class <- taxizedb::classification(exall_sp, db = 'ncbi')
exall_sp_tbl <- map(exall_sp_class, classif2Table) |> 
  bind_rows()
exall_sp_sp <- unique(exall_sp_tbl$species)
map(taxids_ls2, ~ round(mean(exall_sp_sp %in% .x$species) * 100))
```
All parent species are included

```{r}
mean(uu_strains_sp %in% exall_sp_sp)
```

Can we get the same result getting children taxa from species?

```{r}
exall_sp_children <- taxizedb::children(exall_sp_sp, db = 'ncbi')
exall_sp_children <- discard(exall_sp_children, ~ !nrow(.x))
exall_sp_children <- map(exall_sp_children, as.data.frame)
exall_sp_children <- bind_rows(exall_sp_children)
exall_sp_children_strain <- filter(exall_sp_children, rank == 'strain')
```

```{r}
mean(taxids_ls2$exclude_unclassified_uncultured$strain %in% exall_sp_children_strain$id)
```

The set exclude_unclassified_uncultured has the most coverage of bugphyzz
annotations: 

```{r}
mean(bp_ids_ls$strain %in% taxids_ls2$exclude_unclassified_uncultured$strain)
```

Getting chid strains from species in the exclude all seems a good compromise.
Still Most of the bugphyzz annotatiosn will be used.

```{r}
mean(bp_ids_ls$strain %in% exall_sp_children_strain$id)
```


# Final comments

No matter which phhylognetic or taxonomy tree is used, some bugphyzz annotations
will not be used for the propagation step. The best compromise in size of the
tree, performance, and number of bugphyzz annotations used would be:

+ Create a tree with the exclude all set using the species.
+ Use the taxizedb::children function to get child strains.
+ Add extra genera annotated in bugphyzz (if possible).
+ Add extra species annotated in bugphyzz (if possuible).
+ Add extra strains annotated in bugphyzz (if possible).
+ Save tree as a list in exported data.

Note tha the steps above allow for polytomies, which would not be possible
with a phylogenetic tree and a formal ASR method.

# Session information

```{r}
sessioninfo::session_info()
```
