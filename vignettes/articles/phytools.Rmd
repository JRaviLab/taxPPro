---
title: "A propagation workflow with taxonomic pooling, asr (phytools), and inhertiance"
output:
    html_document:
        toc: true
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, message=FALSE}
library(bugphyzz)
library(taxPPro)
library(data.tree)
library(phytools)
library(dplyr)
library(purrr)
library(tidyr)
library(ggplot2)
```

## Import physiology data

```{r import physiology, message=FALSE}
phys <- physiologies('aerophilicity')
```

## Filter data

```{r filter data}
select_cols <- c(
    ## Columns with information needed for propagation
    'NCBI_ID', 'Taxon_name', 'Attribute',
    'Frequency', 'Score', 'Evidence', 
    'Attribute_source', 'Confidence_in_curation',
    'Parent_NCBI_ID',
    
    ## Columns only used for controlling the behavior of the code
    'Attribute_type', 'Attribute_group'
)
valid_ranks <- c('genus', 'species', 'strain')
attributes_fname <- system.file(
    'extdata', 'attributes.tsv', package = 'bugphyzz'
)
attributes <- read.table(attributes_fname, sep = '\t', header = TRUE)
valid_attributes <- attributes |> 
    filter(attribute_group == 'aerophilicity') |> 
    pull(attribute) |> 
    unique()
phys_data <- phys[[1]] |> 
    as_tibble() |> 
    # filter(!is.na(Rank), Rank %in% valid_ranks) |>
    filter(Attribute_value == TRUE) |> # only for discrete traits with multiple states 
    filter(Attribute %in% valid_attributes) |> 
    filter(
        !((is.na(NCBI_ID) | NCBI_ID == 'unknown') & is.na(Parent_NCBI_ID))
    ) |> 
    filter(!is.na('Attribute_source'), !is.na('Frequency')) |>
    mutate( 
        Score = case_when(
            Frequency == 'always' ~ 1,
            Frequency == 'usually' ~ 0.9,
            Frequency == 'sometimes' ~ 0.5,
            Frequency == 'unknown' ~ 0.1 ## arbitrary value
        )
    ) |> 
    select(all_of(select_cols)) |> 
    distinct()
n_dropped_rows <- nrow(phys[[1]]) - nrow(phys_data)
message(format(n_dropped_rows, big.mark = ','), ' rows were dropped.')
```

## Taxonomic pooling for taxa without NCBI_ID (taxid)

Divide data in two sets between taxa with or without NCBI_ID:

```{r, warning=TRUE}
lgl_vct <- is.na(phys_data$NCBI_ID) | phys_data$NCBI_ID == 'unknown'
set_with_ids <- phys_data |> 
    filter(!lgl_vct) |> 
    mutate(
        Rank = taxizedb::taxid2rank(NCBI_ID, db = 'ncbi')
    ) |> 
    filter(Rank %in% valid_ranks) |> 
    mutate(Taxon_name = taxizedb::taxid2name(NCBI_ID, db = 'ncbi')) |> 
    distinct() |> 
    group_by(NCBI_ID, Attribute) |> 
    slice_head(n = 1) |> 
    ungroup() |> 
    group_by(NCBI_ID) |>
    mutate(
        Total_score = sum(Score),
        Score = Score / Total_score
    ) |>
    ungroup() |> 
    select(-Parent_NCBI_ID, -Total_score) |> 
    distinct()
dim(set_with_ids)
```

Get attribute annotations and scores for taxa without NCBI_ID from sources:

```{r}
set_without_ids <- phys_data |> 
    filter(lgl_vct) |> 
    select(-NCBI_ID, -Taxon_name, -Frequency) |> 
    relocate(NCBI_ID = Parent_NCBI_ID) |> 
    mutate(
        Rank = taxizedb::taxid2rank(NCBI_ID, db = 'ncbi')
    ) |> 
    filter(Rank %in% valid_ranks) |> 
    mutate(Taxon_name = taxizedb::taxid2name(NCBI_ID, db = 'ncbi')) |> 
    distinct() |> 
    group_by(NCBI_ID, Attribute) |> 
    slice_head(n = 1) |> 
    ungroup() |> 
    group_by(NCBI_ID) |>
    mutate(
        Total_score = sum(Score),
        Score = Score / Total_score
    ) |>
    mutate(Evidence = 'tax') |> 
    ungroup() |>
    select(-Total_score) |> 
    distinct()
dim(set_without_ids)
```

```{r}
phys_data_ready <- bind_rows(set_with_ids, set_without_ids) |> 
    mutate(
        NCBI_ID = case_when(
            Rank == 'strain' ~ paste0('t__', NCBI_ID),
            Rank == 'species' ~ paste0('s__', NCBI_ID),
            Rank == 'genus' ~ paste0('g__', NCBI_ID),
            TRUE ~ NA
        )
    ) |> 
    filter(!is.na(NCBI_ID)) |> # NAs migth be added because of the mutate call above
    mutate(taxid = sub('^\\w__', '', NCBI_ID))
## Split in lists to use with the NCBI taxonomic tree
phys_data_list <- split(phys_data_ready, factor(phys_data_ready$NCBI_ID))
length(phys_data_list)
```

## Tree data

### Taxonomic tree 

```{r}
data('tree_list')
ncbi_tree <- as.Node(tree_list)
ncbi_tree_nodes <- unname(ncbi_tree$Get('name'))
class(ncbi_tree)
```

### Phylogenectic tree

```{r}
ltp <- ltp()
tree <- ltp$tree
tree
```

### Phylogenetic tree (tip data)

```{r}
tip_data <- ltp$tip_data
dim(tip_data)
```

### Some completeness stats

Annotations from sources than can be mapped to the NCBI tree:

```{r}
ncbi_tree_nodes_gst <- ncbi_tree_nodes[which(grepl('^[wst]__', ncbi_tree_nodes))]
mean(phys_data_ready$NCBI_ID %in% ncbi_tree_nodes_gst)
```

Proportion of NCBI tree nodes (gst) with annotations:

```{r}
mean(ncbi_tree_nodes_gst %in% phys_data_ready$NCBI_ID)
```

Annotations from sources than can me mapped to the phylogenetic tree tips:

```{r}
mean(phys_data_ready$taxid %in% tip_data$taxid)
```

Proportion of tips in the phylogenetic tree with annotations:

```{r}
mean(tip_data$taxid %in% phys_data_ready$taxid)
```

## Increase number of tips with annotations

### Map NCBI IDs to the NCBI taxonomic tree

At this point only genus, species, and strain annotations are present.

```{r}
ncbi_tree$Do(function(node) {
    if (node$name %in% names(phys_data_list)) {
        node$attribute_tbl <- phys_data_list[[node$name]]
    } else {
        NULL
    }
})
## An example (E. coli):
ncbi_tree$d__2$p__1224$c__1236$o__91347$f__543$g__561$s__562$attribute_tbl
```

```{r}
ncbi_attr_gst <- ncbi_tree$Get(
    'attribute_tbl', filterFun = function(node) grepl('^[gst]__', node$name)
)
mean(!map_lgl(ncbi_attr_gst, ~ all(is.na(.x))))
```

Removing annotations just to compare with result after propagation

```{r}
ncbi_tree$d__2$p__1224$c__1236$o__91347$f__543$g__561$attribute_tbl <- NULL
ncbi_tree$d__2$p__1224$c__1236$o__91347$f__543$g__561$attribute_tbl
```

Lest pool and normalize attribute scores at each taxonomic rank (gst) for
child taxa

```{r}
## ASR - post-order
taxPool <- function(node) {
    if (!node$isLeaf) {
        children_names <- names(node$children)
        attribute_tbls <- children_names |> 
            purrr::map(~ node[[.x]]$attribute_tbl) |>
            purrr::discard(is.null)
        not_all_children_tbls_are_null <- length(attribute_tbls) > 0
        node_attribute_tbl_is_null <- is.null(node$table)
        node_is_gst <- grepl('^[gst]__', node$name)
        conds <- node_attribute_tbl_is_null & 
            not_all_children_tbls_are_null &
            node_is_gst
        if (conds) {
            res_tbl <- purrr::discard(attribute_tbls, is.null) |>
                dplyr::bind_rows() |>
                dplyr::select(
                    NCBI_ID, Attribute, Score,
                    Attribute_type, Attribute_group
                ) |> 
                dplyr::mutate(
                    NCBI_ID = node$name,
                    Evidence = 'tax'
                ) |>
                group_by(NCBI_ID) |>
                mutate(
                    Total_score = sum(Score),
                    Score = Score / Total_score
                ) |>
                ungroup() |>
                select(-Total_score) |> 
                group_by(NCBI_ID, Attribute) |> 
                mutate(Score = sum(Score)) |> 
                ungroup() |> 
                distinct() |> 
                mutate(
                    Frequency = case_when(
                        Score == 1 ~ 'always',
                        Score > 0.9 ~ 'usually',
                        Score >= 0.5 ~ 'sometimes',
                        Score > 0 & Score < 0.5 ~ 'rarely',
                        Score == 0 ~ 'never'
                    )
                ) |> 
                distinct()
                node[['attribute_tbl']] <- res_tbl
        } 
    }
}
ncbi_tree$Do(taxPool, traversal = 'post-order')
## Same E. coli example:
ncbi_tree$d__2$p__1224$c__1236$o__91347$f__543$g__561$attribute_tbl
```

How many nodes family and above with attribute table? (it should be zero)

```{r}
ncbi_attr_kpcof <- ncbi_tree$Get(
    'attribute_tbl', filterFun = function(node) grepl('^[kpcor]__', node$name)
)
mean(!map_lgl(ncbi_attr_kpcof, ~ all(is.na(.x))))
```

How many nodes genus and below with attribute table?

```{r}
ncbi_attr_gst <- ncbi_tree$Get(
    'attribute_tbl', filterFun = function(node) grepl('^[gst]__', node$name)
)
## A slight increase 12 to 15%
mean(!map_lgl(ncbi_attr_gst, ~ all(is.na(.x))))
```


Child taxa of  E. coli with unobserved annotations can inherit these
values with a slight penalty:

```{r}
## Inheritance - pre-order
inh1 <- function(node,  adjF = 0.1) {
    if (node$isRoot)
        return(NULL)
    if (is.null(node$parent$attribute_tbl))
        return(NULL)
    if (is.null(node$attribute_tbl) && grepl('^[st]__', node$name)) {
        df <- node$parent$attribute_tbl
        n <- nrow(df)
        df <- df |>
            dplyr::mutate(
                target_scores = rep(1 / n, n),
                score_diff = Score - target_scores,
                Score = Score - adjF * score_diff,
                NCBI_ID = node$name,
                Evidence = 'inh'
            )
        node$attribute_tbl <- df
    }
}
ncbi_tree$Do(inh1, traversal = 'pre-order')
```

Proportion of nodes at the family level and above with attributes:

```{r}
ncbi_attr_kpcof <- ncbi_tree$Get(
    'attribute_tbl', filterFun = function(node) grepl('^[kpcor]__', node$name)
)
mean(!map_lgl(ncbi_attr_kpcof, ~ all(is.na(.x))))
```

Proportion of nodes at the genus, species, and strain levels with attributes:

```{r}
ncbi_attr_gst <- ncbi_tree$Get(
    'attribute_tbl', filterFun = function(node) grepl('^[gst]__', node$name)
)
## Major increase 15 to 78%
mean(!map_lgl(ncbi_attr_gst, ~ all(is.na(.x))))
```

The step above actually covered must of the genus, species, and strains,
but this is one of the datasets with the most annotations, so it's expected
that most of the taxa would already be covered.

A formal ASR method would be nice, however.

Get new attributes:

```{r}
new_attributes <- ncbi_attr_gst |> 
    discard(~ all(is.na(.x))) |> 
    bind_rows() |> 
    arrange(NCBI_ID, Attribute) |> 
    filter(!NCBI_ID %in% phys_data_ready$NCBI_ID) |> 
    mutate(taxid = sub('^\\w__', '', NCBI_ID)) |> 
    bind_rows(phys_data_ready)
table(new_attributes$Evidence)
```

Now almost 90% of the tips have annotations:

```{r}
mean(tip_data$taxid %in% new_attributes$taxid)
```

```{r}
new_tip_data <- left_join(tip_data, new_attributes, by = 'taxid')  
table(new_tip_data$Evidence, useNA = 'always')
```


Let's create an input matrix for ASR with the phylogenetic tree

```{r}
new_tip_data_completed <- new_tip_data |> 
    select(tip_label, Attribute, Score) |> 
    filter(!is.na(Attribute)) |> 
    complete(tip_label, Attribute, fill = list(Score = 0))
m1 <- new_tip_data_completed |> 
    # select(tip_label, Attribute, Score) |> 
    # filter(!is.na(Attribute)) |> 
    # complete(tip_label, Attribute, fill = list(Score = 0)) |>
    pivot_wider(
        names_from = 'Attribute', values_from = 'Score'
    ) |> 
    tibble::column_to_rownames(var = 'tip_label') |>
    as.matrix()

no_annotated_tips <- new_tip_data |>
    filter(!tip_label %in% rownames(m1)) |>
    pull(tip_label) |> 
    unique()

m2 <- matrix(
    data = rep(rep(1/ncol(m1), ncol(m1)), length(no_annotated_tips)),
    nrow = length((no_annotated_tips)),
    byrow = TRUE,
    dimnames = list(rownames = no_annotated_tips, colnames = colnames(m1))
)

m3 <- rbind(m1, m2)
m3 <- m3[tree$tip.label,]
dim(m3)
```

Histogram of probabilites for tips with annotations

```{r}
x <- m1
dim(x) <- NULL
data.frame(prob = x) |> 
    ggplot(aes(prob)) +
    geom_histogram(binwidth = 0.1) +
    ggtitle('Tips with annotations, all probabilities')
```

```{r}
y <- as.double(apply(m1, 1, max))
data.frame(prob = y) |> 
    ggplot(aes(prob)) +
    geom_histogram(binwidth = 0.1) +
    ggtitle('Tips with annotations, max probabilities')
```

```{r}
z <- m3
dim(z) <- NULL
data.frame(prob = z) |> 
    ggplot(aes(prob)) +
    geom_histogram(binwidth = 0.1) +
    ggtitle('All tips, all probabilities')
```

## ASR with phytools

```{r}
system.time({
    fit <- fitMk(
        tree = tree, x = m3, model = 'ER', pi = 'fitzjohn', 
        lik.func = 'pruning', logscale = TRUE
    )
    asr <- ancr(object = fit, tips = TRUE)
})
```


```{r}
res <- asr$ace
node_rows <- length(tree$tip.label) + 1:tree$Nnode
rownames(res)[node_rows] <- tree$node.label
```

Probabiliites of internal nodes

```{r}
data.frame(prob = as.double(res[tree$node.label,])) |> 
    ggplot(aes(prob)) +
    geom_histogram(binwidth = 0.1) +
    ggtitle('Internal nodes, all probabilities')
```


Probabilities of tips

```{r}
data.frame(prob = as.double(res[tree$tip.label,])) |> 
    ggplot(aes(prob)) +
    geom_histogram(binwidth = 0.1) +
    ggtitle('Tips, all probabilities (after ASR)')

```


```{r}
maxRes <- unlist(apply(res, 1, max))
data.frame(prob = maxRes[tree$node.label]) |> 
    ggplot(aes(prob)) +
    geom_histogram(binwidth = 0.1) +
    ggtitle('Internal nodes, max probabilities')
```

```{r}
data.frame(prob = maxRes[rownames(m2)]) |> 
    ggplot(aes(prob)) +
    geom_histogram(binwidth = 0.1) +
    ggtitle('New tips, max probabilities')
```

```{r}
new_taxa_from_tips <- res[rownames(m2),] |> 
    as.data.frame() |> 
    tibble::rownames_to_column(var = 'tip_label') |> 
    left_join(tip_data, by = 'tip_label') |> 
    mutate(
        Rank = taxizedb::taxid2rank(taxid, db = 'ncbi')
    ) |> 
    filter(Rank %in% c('genus', 'species', 'strain')) |> 
    mutate(
        NCBI_ID = case_when(
            Rank == 'genus' ~ paste0('g__', taxid),
            Rank == 'species' ~ paste0('s__', taxid),
            Rank == 'strain' ~ paste0('t__', taxid)
        )
    ) |> 
    rename(Taxon_name = taxname) |> 
    select(-ends_with('_taxid'), -tip_label, -taxid, -accession) |> 
    relocate(NCBI_ID, Taxon_name, Rank) |> 
    pivot_longer(
        names_to = 'Attribute', values_to = 'Score', cols = 4:last_col()
    ) |> 
    mutate(Evidence = 'asr')
head(new_taxa_from_tips)
```

Most of these new taxa are in the NCBI tree:

```{r}
ncbi_tree_nodes_empty <- ncbi_tree$Get(
    'attribute_tbl', filterFun = function(node) {
        is.null(node$attribute_tbl) || all(is.na(node$attribute_tbl))   
    }) |> 
    {\(y) names(y)}()
mean(new_taxa_from_tips$NCBI_ID %in% ncbi_tree_nodes_empty)
```

Let's check nodes


```{r}
nodes_annotated <- res[which(grepl('^\\d+(\\+\\d+)*', rownames(res))),]
new_taxa_from_nodes <- nodes_annotated |> 
    as.data.frame() |> 
    tibble::rownames_to_column(var = 'NCBI_ID') |> 
    mutate(NCBI_ID = strsplit(NCBI_ID, '\\+')) |> 
    tidyr::unnest(NCBI_ID) |> 
    mutate(Rank = taxizedb::taxid2rank(NCBI_ID)) |> 
    mutate(Rank = ifelse(Rank == 'superkingdom', 'kingdom', Rank)) |> 
    mutate(
        NCBI_ID = case_when(
            Rank == 'kingdom' ~ paste0('d__', NCBI_ID),
            Rank == 'phylum' ~ paste0('p__', NCBI_ID),
            Rank == 'class' ~ paste0('c__', NCBI_ID),
            Rank == 'order' ~ paste0('o__', NCBI_ID),
            Rank == 'family' ~ paste0('f__', NCBI_ID),
            Rank == 'genus' ~ paste0('g__', NCBI_ID),
            Rank == 'species' ~ paste0('s__', NCBI_ID),
            Rank == 'strain' ~ paste0('t__', NCBI_ID)
        )
    ) |> 
    filter(
        Rank %in% c(
            'kingdom', 'phylum', 'class', 'order', 'family', 'genus',
            'species', 'strain'
        )
    ) |> 
    mutate(Evidence = 'asr') |> 
    relocate(NCBI_ID, Rank, Evidence) |> 
    pivot_longer(
        cols = 4:last_col(), names_to = 'Attribute', values_to = 'Score'
    )
head(new_taxa_from_nodes)
```

Some new taxa can be added to the empty:

```{r}
mean(new_taxa_from_nodes$NCBI_ID %in% ncbi_tree_nodes_empty)
```

Actually most are already in the tree, but we got them throuh taxonomic
binning (genus, species, and strains)

```{r}
mean(new_taxa_from_nodes$NCBI_ID %in% ncbi_tree_nodes)
```


Prepare new taxa:

```{r}
new_taxa_for_ncbi_tree <- new_taxa_from_tips |> 
    select(-Taxon_name) |> 
    relocate(NCBI_ID, Rank, Attribute, Score, Evidence) |> 
    bind_rows(new_taxa_from_nodes)
new_taxa_for_ncbi_tree_list <- split(
    new_taxa_for_ncbi_tree, factor(new_taxa_for_ncbi_tree$NCBI_ID)
)
```

Let's add some taxa to the tree:

```{r}
ncbi_tree$Do(function(node) {
    cond1 <- node$name %in% names(new_taxa_for_ncbi_tree_list)
    cond2 <- is.null(node$attribute_tbl) || all(is.na(node$attribute_tbl))
    if (cond1 && cond2) {
        node$attribute_tbl <- new_taxa_for_ncbi_tree_list[[node$name]]
    }
})
```

How many are empty after this:

```{r}
ncbi_tree_nodes_empty2 <- ncbi_tree$Get(
    'attribute_tbl', filterFun = function(node) {
        is.null(node$attribute_tbl) || all(is.na(node$attribute_tbl))   
    }) |> 
    {\(y) names(y)}()
## There are still some empty nodes that most be filled
length(ncbi_tree_nodes_empty2)
```

Inheritance one more time:

```{r}
inh2 <- function(node, adjF = 0.1) {
    cond1 <- !node$isRoot # don't apply this to the root
    cond2 <- is.null(node$attribute_tbl) # attribute_tbl must be empty
    cond3 <- !is.null(node$parent$attribute_tbl) # parent must have data
    if (cond1 && cond2 && cond3) {
        # message('Adding ', node$name, '.')
        tbl <- node$parent$attribute_tbl  
        n <- nrow(tbl)
        res <- tbl |> 
            mutate(
                target_scores = rep(1 / n, n),
                score_diff = Score - target_scores,
                Score = Score - adjF * score_diff,
                NCBI_ID = node$name,
                Evidence = 'inh2'
            ) |>
            select(-target_scores, -score_diff) |> 
            relocate(NCBI_ID)
        node$attribute_tbl <- res
    }
}
ncbi_tree$Do(inh2, traversal = 'pre-order')
```


How many are empty after this:

```{r}
ncbi_tree_nodes_empty2 <- ncbi_tree$Get(
    'attribute_tbl', filterFun = function(node) {
        is.null(node$attribute_tbl) || all(is.na(node$attribute_tbl))   
    }) |> 
    {\(y) names(y)}()
## Only the root (ArcBac) remains empty
length(ncbi_tree_nodes_empty2)
```

```{r}
ncbi_tree$d__2$p__1224$c__28211$o__356$f__335928$attribute_tbl
```

Get all the tables

```{r}
output <- ncbi_tree$Get(
    attribute = 'attribute_tbl', simplify = FALSE,
    filterFun = function(node) node$name != 'ArcBac'
    )
output <- bind_rows(output)
head(output)
```

```{r}
min_thr <- 1 / length(unique(phys_data_ready$Attribute))
addTaxa1 <- phys_data_ready |> 
    filter(!NCBI_ID %in% unique(output$NCBI_ID))
addTaxa2 <- new_taxa_for_ncbi_tree|> 
    filter(!NCBI_ID %in% unique(output$NCBI_ID))
final_output <- bind_rows(list(output, addTaxa1, addTaxa2)) |> 
    filter(Score > min_thr)
dim(final_output)
```

## Session information

```{r}
sessioninfo::session_info()
```
