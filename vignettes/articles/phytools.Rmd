---
title: "A propagation workflow"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, message=FALSE}
library(bugphyzz)
library(taxPPro)
library(data.tree)
library(phytools)
library(dplyr)
library(purrr)
library(tidyr)
```

Import physiology data (1 physiology - aerophilicity)

```{r import physiology, message=FALSE}
phys <- physiologies('aerophilicity')
```

Filter data:

```{r filter data}
select_cols <- c(
    ## Columns with information needed for propagation
    'NCBI_ID', 'Taxon_name', 'Attribute', 'Attribute_source',
    'Frequency', 'Score', 'Parent_NCBI_ID', 'Confidence_in_curation',
    ## Columns only used for controlling the behavior of the code
    'Attribute_type', 'Attribute_group' # I might need one or two more!
)
valid_ranks <- c('genus', 'species', 'strain')
phys_data <- phys[[1]] |> 
    as_tibble() |> 
    filter(Attribute_value == TRUE) |> # only use TRUE values for this physiology (non-binary and represents an intersection)
    filter(!is.na(Rank), Rank %in% valid_ranks) |> 
    filter(
        ## Only rows with NCBI_ID or Parent_NCBI_ID if NCBI absent can be used
        !((is.na(NCBI_ID) | NCBI_ID == 'unknown') & is.na(Parent_NCBI_ID))
    ) |> 
    filter(!is.na('Attribute_source'), !is.na('Frequency')) |> 
    mutate(
        Score = case_when(
            Frequency == 'always' ~ 1,
            Frequency == 'usually' ~ 0.9,
            Frequency == 'sometimes' ~ 0.5,
            Frequency == 'unknown' ~ 0.1 ## arbitrary value
        )
    ) |> 
    select(all_of(select_cols)) |> 
    distinct()

n_dropped_rows <- nrow(phys[[1]]) - nrow(phys_data)
message(format(n_dropped_rows, big.mark = ','), ' rows were dropped.')
```

#> TODO - add code for dealing with duplicates, etc.

The phylogenetic and taxonomic trees used for propagation with
ASR and inheritance have NCBI IDs at the node and tip labels.
Therefore, only annotations with NCBI IDs can be mapped for propagation
(ASR and Inheritance).

The annotations of taxa without NCBI ID (usually strains) can be used to infer
the annotations of their parents (with NCBI ID and usually species) through
an 'early' version of ASR (before applying a formal ASR method).

This early version of ASR is just the normalization of scores among the
child nodes of a parent node.

```{r divide data in sets 1 and 2}
lgl_vct <- is.na(phys_data$NCBI_ID) | phys_data$NCBI_ID == 'unknown'
set_with_ids <- phys_data |> 
    filter(!lgl_vct) |> 
    group_by(NCBI_ID) |> 
    mutate(Taxon_name = paste0(sort(unique(Taxon_name)), collapse = '|')) |> 
    ungroup() |> 
    distinct() |> 
    group_by(NCBI_ID) |> 
    mutate(
        n = dplyr::n(),
    ) |> 
    ungroup() |> 
    group_by(NCBI_ID, Attribute) |> 
    mutate(Normalized_score = sum(Score) / n) |> 
    ungroup() |> 
    select(-Score, -n) |> 
    rename(Score = Normalized_score) |> 
    distinct()
dim(set_with_ids) # these data don't need to go through early ASR
```

```{r set2 for asr}
## this will be used for early ASR
set_without_ids <- phys_data |> 
    filter(lgl_vct) |> 
    select(-NCBI_ID, -Taxon_name, -Frequency) |> 
    relocate(NCBI_ID = Parent_NCBI_ID) |> 
    distinct()

if (nrow(set_with_ids) > 0) {
    set_without_ids <- set_without_ids |> 
        filter(!NCBI_ID %in% unique(set_with_ids$NCBI_ID))
}
dim(set_without_ids)
```

Let's just add up the scores


#> set_without_ids |> filter(NCBI_ID %in% set_without_ids$NCBI_ID[which(duplicated(set_without_ids$NCBI_ID))])
#> x |> filter(NCBI_ID %in% x$NCBI_ID[which(duplicated(x$NCBI_ID))])

```{r}
## 55565
set_without_ids <- set_without_ids |> 
    group_by(NCBI_ID) |> 
    mutate(
        n = dplyr::n(),
    ) |> 
    ungroup() |> 
    group_by(NCBI_ID, Attribute) |> 
    mutate(Normalized_score = sum(Score) / n) |> 
    ungroup() |> 
    select(-Score, -n) |> 
    rename(Score = Normalized_score) |> 
    distinct()
phys_data_ready <- left_join(set_with_ids, set_without_ids)
```

I need a matrix of prior probabilites

```{r}
phys_data_ready <- phys_data_ready |> 
    group_by(NCBI_ID, Attribute) |> 
    slice_head(n = 1) |> 
    ungroup()
input_mat <- phys_data_ready |> 
    select(NCBI_ID, Attribute, Score) |> 
    pivot_wider(
        names_from = Attribute, values_from = Score, values_fill = 0
    ) |> 
    tibble::column_to_rownames(var = 'NCBI_ID') |> 
    as.matrix()
sum(rowSums(input_mat))
```












Load data:

```{r}
data("primate.tree")
data("primate.data")
tree <- primate.tree
data <- primate.data
rm(primate.tree)
rm(primate.data)
activity <- data$Activity_pattern
names(activity) <- rownames(data)
m <- to.matrix(activity, levels(activity))
m[,] <- rep(1/ncol(m), ncol(m))
labs <- rownames(m)[which(grepl('Galago', rownames(m)))]
for (i in seq_along(labs)) {
    m[labs[i],] <- c(0, 0, 1)
}
fit <- fitMk(
    tree = tree, x = m, model = 'ARD', pi = "fitzjohn", logscale = TRUE, 
    lik.func = "pruning"
)
ace <- ancr(fit, tips = TRUE)
res <- ace$ace

```






```{r}
plot(ace, args.plotTree = list(direction = "upwards"))
tips <- sapply(labs, function(x, y) which(y == x), y = tree$tip.label)
add.arrow(tree, tips, arrl = 3, offset = 2, lwd = 2, col = palette()[4])
```


















