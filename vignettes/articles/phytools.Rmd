---
title: "A propagation workflow"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, message=FALSE}
library(bugphyzz)
library(taxPPro)
library(data.tree)
library(phytools)
library(dplyr)
library(purrr)
library(tidyr)
```

Import physiology data (1 physiology - aerophilicity)

```{r import physiology, message=FALSE}
phys <- physiologies('aerophilicity')
```

Filter data:

```{r filter data}
select_cols <- c(
    ## Columns with information needed for propagation
    'NCBI_ID', 'Taxon_name', 'Attribute', 'Attribute_source',
    'Frequency', 'Score', 'Parent_NCBI_ID', 'Confidence_in_curation',
    'Rank', 'Evidence',
    ## Columns only used for controlling the behavior of the code
    'Attribute_type', 'Attribute_group' # I might need one or two more!
)
valid_ranks <- c('genus', 'species', 'strain')
phys_data <- phys[[1]] |> 
    as_tibble() |> 
    filter(Attribute_value == TRUE) |> # only use TRUE values for this physiology (non-binary and represents an intersection)
    filter(!is.na(Rank), Rank %in% valid_ranks) |> # need valid ranks
    filter(
        ## Only rows with NCBI_ID or Parent_NCBI_ID if NCBI is missing can be used
        !((is.na(NCBI_ID) | NCBI_ID == 'unknown') & is.na(Parent_NCBI_ID))
    ) |> 
    filter(!is.na('Attribute_source'), !is.na('Frequency')) |>  # need source and frequency
    mutate( # Frequency keywords shold be converted to numeric scores. 
        Score = case_when(
            Frequency == 'always' ~ 1,
            Frequency == 'usually' ~ 0.9,
            Frequency == 'sometimes' ~ 0.5,
            Frequency == 'unknown' ~ 0.1 ## arbitrary value
        )
    ) |> 
    select(all_of(select_cols)) |> 
    distinct()
n_dropped_rows <- nrow(phys[[1]]) - nrow(phys_data)
message(format(n_dropped_rows, big.mark = ','), ' rows were dropped.')
```

#> TODO - add code for dealing with duplicates, etc.

The phylogenetic and taxonomic trees used for propagation with
ASR and inheritance have NCBI IDs at the node and tip labels.
Therefore, only annotations with NCBI IDs can be mapped for propagation
(ASR and Inheritance).

The annotations of taxa without NCBI ID (usually strains) can be used to infer
the annotations of their parents (with NCBI ID and usually species) through
an 'early' version of ASR (before applying a formal ASR method).

This early version of ASR is just the normalization of scores among the
child nodes of a parent node.

```{r divide data in sets 1 and 2}
lgl_vct <- is.na(phys_data$NCBI_ID) | phys_data$NCBI_ID == 'unknown'
set_with_ids <- phys_data |> 
    filter(!lgl_vct) |> 
    ## I need to do this here (when rows with NCBI IDs have been
    ## separated from rows without NCBI_IDs). Maybe I can do this before
    ## separated with mutate_if or other code.
    group_by(NCBI_ID) |> 
    mutate(Taxon_name = paste0(sort(unique(Taxon_name)), collapse = '|')) |> 
    ungroup() |> 
    distinct() |> 
    group_by(NCBI_ID, Attribute) |> 
    slice_head(n = 1) |> 
    ungroup() |> 
    group_by(NCBI_ID) |>
    mutate(
        Total_score = sum(Score),
        Score = Score / Total_score
    ) |>
    ungroup() |> 
    distinct()
dim(set_with_ids) # these data don't need to go through early ASR
```

```{r set2 for asr}
## this will be used for early ASR
set_without_ids <- phys_data |> 
    filter(lgl_vct) |> 
    select(-NCBI_ID, -Taxon_name, -Frequency) |> 
    relocate(NCBI_ID = Parent_NCBI_ID) |> 
    distinct()

if (nrow(set_with_ids) > 0) {
    set_without_ids <- set_without_ids |> 
        filter(!NCBI_ID %in% unique(set_with_ids$NCBI_ID))
}
## add some code here in case all of the NCBI_IDs were alredy present in
## the original data
dim(set_without_ids)
```

Let's just add up the scores

#> set_without_ids |> filter(NCBI_ID %in% set_without_ids$NCBI_ID[which(duplicated(set_without_ids$NCBI_ID))])
#> x |> filter(NCBI_ID %in% x$NCBI_ID[which(duplicated(x$NCBI_ID))])

```{r}
## 55565
set_without_ids <- set_without_ids |>    
    group_by(NCBI_ID, Attribute) |> 
    slice_head(n = 1) |> 
    ungroup() |> 
    group_by(NCBI_ID) |>
    mutate(
        Total_score = sum(Score),
        Score = Score / Total_score
    ) |>
    ungroup() |>
    distinct()
phys_data_ready <- left_join(set_with_ids, set_without_ids) |> 
    select(-Total_score, -Parent_NCBI_ID) |> 
    mutate(
        NCBI_ID = case_when(
            Rank == 'strain' ~ paste0('t__', NCBI_ID),
            Rank == 'species' ~ paste0('s__', NCBI_ID),
            Rank == 'genus' ~ paste0('g__', NCBI_ID)
    )
)
phys_data_list <- split(phys_data_ready, factor(phys_data_ready$NCBI_ID))
length(phys_data_list)
```

## First part of ASR/INH

Map all nodes to the data_tree file

```{r}
data("tree_list")
data_tree <- as.Node(tree_list)
print(data_tree, limit = 10)
```

How many tips/nodes included in the NCBI taxonomy

```{r}
get_all_nodes <- unname(data_tree$Get('name'))
mean(names(phys_data_list) %in% get_all_nodes)
```

How many tips included in the mpa tree

```{r}
mpa_tip_data <- mpa(x = 'tips') |> 
    modify(as.character) |> 
    as_tibble()
mean(mpa_tip_data$taxid %in% sub('^\\w__', '', phys_data_ready$NCBI_ID))
```
Add nodes to the tree

```{r}
data_tree$Do(function(node) {
    if (node$name %in% names(phys_data_list)) {
        node$attribute_tbl <- phys_data_list[[node$name]]
    } else {
        NULL
    }
})
data_tree$d__2$p__1224$c__1236$o__91347$f__543$g__561$s__562$attribute_tbl
```


```{r}
data_tree$d__2$p__1224$c__1236$o__91347$f__543$g__561$attribute_tbl <- NULL
data_tree$d__2$p__1224$c__1236$o__91347$f__543$g__561$attribute_tbl
```

ASR - post-order

```{r}
asr1 <- function(node) {
    if (!node$isLeaf) {
        children_names <- names(node$children)
        attribute_tbls <- children_names |> 
            purrr::map(~ node[[.x]]$attribute_tbl) |>
            purrr::discard(is.null)
        not_all_children_tbls_are_null <- length(attribute_tbls) > 0
        node_attribute_tbl_is_null <- is.null(node$table)
        node_is_gst <- grepl('^[gst]__', node$name)
        conds <- node_attribute_tbl_is_null & 
            not_all_children_tbls_are_null &
            node_is_gst
        if (conds) {
            res_tbl <- purrr::discard(attribute_tbls, is.null) |>
                dplyr::bind_rows() |>
                dplyr::select(
                    NCBI_ID, Attribute, Score,
                    Attribute_type, Attribute_group
                ) |> 
                dplyr::mutate(
                    NCBI_ID = node$name,
                    Evidence = 'asr1'
                ) |>
                group_by(NCBI_ID) |>
                mutate(
                    Total_score = sum(Score),
                    Score = Score / Total_score
                ) |>
                ungroup() |>
                select(-Total_score) |> 
                group_by(NCBI_ID, Attribute) |> 
                mutate(Score = sum(Score)) |> 
                ungroup() |> 
                distinct() |> 
                mutate(
                    Frequency = case_when(
                        Score == 1 ~ 'always',
                        Score > 0.9 ~ 'usually',
                        Score >= 0.5 ~ 'sometimes',
                        Score > 0 & Score < 0.5 ~ 'rarely',
                        Score == 0 ~ 'never'
                    )
                ) |> 
                distinct()
                node[['attribute_tbl']] <- res_tbl
        } 
    }
}
data_tree$Do(asr1, traversal = 'post-order')
data_tree$d__2$p__1224$c__1236$o__91347$f__543$g__561$attribute_tbl
```

```{r}
inh1 <- function(node) {
    
}


data_tree$Do()
```
















```{r}
new_nodes <- data_tree$Get('attribute_tbl', simplify = FALSE)
new_nodes_not_na <- map_lgl(new_nodes, ~ !all(is.na(.x)))
mean(new_nodes_not_na)
```

```{r}
new_data <-  new_nodes |> 
    discard(~ all(is.na(.x))) |> 
    bind_rows() |> 
    arrange(NCBI_ID, Attribute) |> 
    mutate(taxid = sub('^\\w__', '', NCBI_ID))
## just a slight increase. More useful in datasets with only genus
## and strain information, but no species, I think.
mean(mpa_tip_data$taxid %in% new_data$taxid)
```
```{r}
tip <- left_join(
    mpa_tip_data, new_data, by = 'taxid', relationship = 'many-to-many'
)  
tip |> 
    filter(!is.na(Attribute)) |> 
    dim()
```


```{r}
table(tip$Evidence)
```


```{r}
mpa_tree <- mpa()
m1 <- tip |> 
    select(tip_label, Attribute, Score) |> 
    filter(!is.na(Attribute)) |> 
    # complete(NCB_ID, Attribute, fill = list(Score = 0)) |> 
    pivot_wider(
        names_from = Attribute, values_from = 'Score', values_fill = 0
    ) |> 
    tibble::column_to_rownames(var = 'tip_label') |> 
    as.matrix()

no_annotated_tips <- tip |>
    filter(!tip_label %in% rownames(m1)) |>
    pull(tip_label)

m2 <- matrix(
    data = rep(rep(1/ncol(m1), ncol(m1)), length(no_annotated_tips)),
    nrow = length((no_annotated_tips)),
    byrow = TRUE,
    dimnames = list(rownames = no_annotated_tips, colnames = colnames(m1))
)

m3 <- rbind(m1, m2)
m3 <- m3[mpa_tree$tip.label,]
dim(m3)
```
```{r}
system.time(
    fit <- fitMk.parallel(
        tree = mpa_tree, 
        x = m3, 
        model = 'ER', 
        pi = "fitzjohn", 
        logscale = TRUE, 
        lik.func = "pruning"
    )
)
## Took close to 1 hour the fitMK
## Took about 4 min with parallel, but I got some NaNs warnings.
```

```{r}
system.time(
    # ace <- ancr(fit, type = 'marginal', tips = TRUE) 
    ace <- ancr(fit, type = 'marginal') # don't include tips
)
```




```{r}
node_data <- mpa('nodes')
res <- ace$ace
rownames(res) <- mpa_tree$node.label
res <- res |> 
    as.data.frame() |> 
    tibble::rownames_to_column(var = 'node_label') |> 
    left_join(node_data, by = 'node_label') |> 
    as_tibble() |> 
    filter(!is.na(taxid))
dim(res)
```


```{r}
select()
```
















```{r}
data('tree_list')
data_tree <- as.Node(tree_list)
data_tree$Do(function(node) {
    node$name <- sub('\\w__', '', node$name)
})

data_tree_node_names <- unname(data_tree$Get('name'))
mean(res$taxid %in% data_tree_node_names)
```


```{r}
l <- split(res, factor(res$taxid))
l <- map(l, ~ {
    .x |> 
    select(
        aerobic, anaerobic, `facultatively anaerobic`, `facultative aerobe`
    ) |> 
        pivot_longer(
            names_to = 'attribute', values_to = 'score',
            cols = c('aerobic', 'anaerobic', 'facultatively anaerobic', 'facultative aerobe')
        )
})
```

```{r}
data_tree$Do(function(node) {
    if (node$name %in% names(l)) {
        node$attribute_tbl <- l[[node$name]]
    } else {
        NULL
    }
})

```



```{r}
plot(ace, args.plotTree = list(direction = "upwards"))
# tips <- sapply(labs, function(x, y) which(y == x), y = tree$tip.label)
# add.arrow(tree, tips, arrl = 3, offset = 2, lwd = 2, col = palette()[4])

```












I need a matrix of prior  probabilites

```{r}
prior_prob_mat <- phys_data_ready |> 
    select(NCBI_ID, Attribute, Score) |> 
    pivot_wider(
        names_from = Attribute, values_from = Score, values_fill = 0
    ) |> 
    tibble::column_to_rownames(var = 'NCBI_ID') |> 
    as.matrix()
sum(rowSums(prior_prob_mat)) == nrow(prior_prob_mat)
```


Import phylogenetic tree (living tree project):

```{r}
# fname <- system.file(
#     'extdata', 'livingTree.newick', package = 'taxPPro', mustWork = TRUE
# )
# tree <- read.tree(fname)
# tree
data('tree_list')
data_tree <- as.Node(tree_list)
tree <- as.phylo.Node(data_tree, heightAttribute = NULL)
tree <- multi2di(tree)
tree <- collapse.singles(tree)
tree$tip.label <- sub('\\w__', '', tree$tip.label)
tree$node.label <- sub('\\w__', '', tree$node.label)
tree
```


```{r}
is.binary(tree)
```


Add internal nodes (if any):

```{r add internal nodes}
temp <- tree
temp$edge.length[which(temp$edge.length == 0)] <- head(sort(unique(temp$edge.length)))[2]
node_labels <- unique(temp$node.label)
node_labels <- node_labels[node_labels != '']
node_labels <- unlist(strsplit(node_labels, '\\+'))
mat <- prior_prob_mat[which(rownames(prior_prob_mat) %in% node_labels), , drop = TRUE]
nodes <- rownames(mat)
system.time(
for(i in seq_along(nodes)){
    regex <- paste0('\\b', nodes[i], '\\b')
    tipsAndNodes <- c(temp$tip.label, temp$node.label)
    pos <- grep(regex, tipsAndNodes)
    if (!length(pos))
        next
    temp <- bind.tip(
        tree = temp, tip.label = nodes[i], edge.length = 0, where = pos
    )
}
)
```

Let's fit a model of evolution

```{r fit model}
missing_tips <- temp$tip.label[!(temp$tip.label %in% rownames(mat))]
values <- rep(1/ncol(mat), ncol(mat))
mat2 <- matrix(rep(values, length(missing_tips)), ncol = ncol(mat), byrow = TRUE)
rownames(mat2) <- missing_tips
colnames(mat2) <- colnames(mat)
mat3 <- rbind(mat, mat2)
mat3 <- mat3[temp$tip.label,]
fit <- fitMk(
        # extended Mk (hidden markov) model (used for discrete traits)
    tree = temp, 
    x = mat3, 
    model = 'ARD',  # all rates different
    pi = "fitzjohn",  # pror distribution at the root this seems to have a significant effect in the root
    logscale = TRUE, 
    lik.func = "pruning",
)
```

Load data:

```{r}
data("primate.tree")
data("primate.data")
tree <- primate.tree
data <- primate.data
rm(primate.tree)
rm(primate.data)
activity <- data$Activity_pattern
names(activity) <- rownames(data)
m <- to.matrix(activity, levels(activity))
m[,] <- rep(1/ncol(m), ncol(m))
labs <- rownames(m)[which(grepl('Galago', rownames(m)))]
for (i in seq_along(labs)) {
    m[labs[i],] <- c(0, 0, 1)
}
fit <- fitMk(
    tree = tree, x = m, model = 'ARD', pi = "fitzjohn", logscale = TRUE, 
    lik.func = "pruning"
)
ace <- ancr(fit, tips = TRUE)
res <- ace$ace


```


```{r}
plot(ace, args.plotTree = list(direction = "upwards"))
tips <- sapply(labs, function(x, y) which(y == x), y = tree$tip.label)
add.arrow(tree, tips, arrl = 3, offset = 2, lwd = 2, col = palette()[4])
```
