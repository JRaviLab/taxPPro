---
title: "A propagation workflow"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, message=FALSE}
library(bugphyzz)
library(taxPPro)
library(data.tree)
library(phytools)
library(dplyr)
library(purrr)
library(tidyr)
```

Load bugphyzz data (one physiology - aerophilicity):

```{r import physiology data}
aer <- physiologies('aerophilicity')[[1]]
select_cols <- c(
    ## Columns with information really needed
    'NCBI_ID', 'Taxon_name', 'Attribute', 'Attribute_value', 'Attribute_source',
    'Frequency', 'Parent_NCBI_ID', 'Confidence_in_curation',
    ## Columns only used for controlling the behaviour of the code
    'Attribute_type', 'Attribute_group'
)
phys_data <- aer |> 
    as_tibble() |> 
    select(all_of(select_cols)) |> 
    filter(Attribute_value == TRUE) |> # only use TRUE values for this physiology (non-binary and represents an intersection)
    select(-Attribute_value) |> 
    filter(
        ## Only rows with NCBI_ID or Parent_NCBI_ID if NCBI absent can be used
        !((is.na(NCBI_ID) | NCBI_ID == 'unknown') & is.na(Parent_NCBI_ID))
    ) |> 
    filter(!is.na('Attribute_source'), !is.na('Frequency')) |> 
    mutate(
        Score = case_when(
            Frequency == 'always' ~ 1,
            Frequency == 'usually' ~ 0.9,
            Frequency == 'sometimes' ~ 0.5,
            Frequency == 'unknown' ~ 0.1 ## arbitrary value
        )
    ) |> 
    distinct()

n_dropped_rows <- nrow(aer) - nrow(phys_data)
message(format(n_dropped_rows, big.mark = ','), ' rows were dropped.')
```

The phylogenetic and taxonomic trees used for propagation with
ASR and inheritance have NCBI IDs at the node and tip labels.
Therefore, only annotations with NCBI IDs can be mapped for propagation
(ASR and Inheritance).

The annotations of taxa without NCBI ID (usually strains) can be used to infer
the annotations of their parents (with NCBI ID and usually species) through
an 'early' version of ASR (before applying a formal ASR method).

This early version of ASR is just the normalization of scores among the
child nodes of a parent node.

```{r}
lgl_vct <- is.na(phys_data$NCBI_ID) | phys_data$NCBI_ID == 'unknown'
set_with_ids <- phys_data |> 
    filter(!lgl_vct) |> 
    group_by(NCBI_ID) |> 
    mutate(Taxon_name = paste0(sort(unique(Taxon_name)), collapse = '|')) |> 
    ungroup() |> 
    distinct()
dim(set_with_ids) # no need for early ASR
```

```{r}
set_without_ids <- phys_data |> 
    filter(lgl_vct) |> 
    select(-NCBI_ID, -Taxon_name, -Frequency) |> 
    relocate(NCBI_ID = Parent_NCBI_ID)
    # this will be used for early ASR
dim(set_without_ids)
```

```{r}



    
```

















Load data:

```{r}
data("primate.tree")
data("primate.data")
tree <- primate.tree
data <- primate.data
rm(primate.tree)
rm(primate.data)
activity <- data$Activity_pattern
names(activity) <- rownames(data)
m <- to.matrix(activity, levels(activity))
m[,] <- rep(1/ncol(m), ncol(m))
labs <- rownames(m)[which(grepl('Galago', rownames(m)))]
for (i in seq_along(labs)) {
    m[labs[i],] <- c(0, 0, 1)
}
fit <- fitMk(
    tree = tree, x = m, model = 'ARD', pi = "fitzjohn", logscale = TRUE, 
    lik.func = "pruning"
)
ace <- ancr(fit, tips = TRUE)
res <- ace$ace

```






```{r}
plot(ace, args.plotTree = list(direction = "upwards"))
tips <- sapply(labs, function(x, y) which(y == x), y = tree$tip.label)
add.arrow(tree, tips, arrl = 3, offset = 2, lwd = 2, col = palette()[4])
```

