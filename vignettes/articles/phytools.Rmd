---
title: "A propagation workflow"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, message=FALSE}
library(bugphyzz)
library(taxPPro)
library(data.tree)
library(phytools)
library(dplyr)
library(purrr)
library(tidyr)
```

This workflow is for categorical attributes

## Import physiology data

```{r import physiology, message=FALSE}
phys <- physiologies('aerophilicity')
```

## Filter data

```{r filter data}
select_cols <- c(
    ## Columns with information needed for propagation
    'NCBI_ID', 'Taxon_name', 'Attribute', 'Attribute_source',
    'Frequency', 'Score', 'Parent_NCBI_ID', 'Confidence_in_curation',
    'Rank', 'Evidence',
    
    ## Columns only used for controlling the behavior of the code
    'Attribute_type', 'Attribute_group'
)
valid_ranks <- c('genus', 'species', 'strain')

## It's worth checking the ranks

phys_data <- phys[[1]] |> 
    as_tibble() |> 
    filter(Attribute_value == TRUE) |> # only for discrete traits with multiple states 
    filter(!is.na(Rank), Rank %in% valid_ranks) |>
    filter(
        ## Filter rows with NCBI_ID.
        ## If NCBI_ID is missing, Parent_NCBI_ID must be present
        !((is.na(NCBI_ID) | NCBI_ID == 'unknown') & is.na(Parent_NCBI_ID))
    ) |> 
    filter(!is.na('Attribute_source'), !is.na('Frequency')) |>
    mutate( 
        Score = case_when(
            Frequency == 'always' ~ 1,
            Frequency == 'usually' ~ 0.9,
            Frequency == 'sometimes' ~ 0.5,
            Frequency == 'unknown' ~ 0.1 ## arbitrary value
        )
    ) |> 
    select(all_of(select_cols)) |> 
    distinct()
n_dropped_rows <- nrow(phys[[1]]) - nrow(phys_data)
message(format(n_dropped_rows, big.mark = ','), ' rows were dropped.')
```

## First round of ASR (taxonomic binning) for taxa withoud NCBI ID (taxid)

Divide data into two sets: 1) with taxids and 2) without taxids.

```{r divide data in sets 1 and 2}
lgl_vct <- is.na(phys_data$NCBI_ID) | phys_data$NCBI_ID == 'unknown'
set_with_ids <- phys_data |> 
    filter(!lgl_vct) |> 
    group_by(NCBI_ID) |> 
    mutate(Taxon_name = paste0(sort(unique(Taxon_name)), collapse = '|')) |> 
    ungroup() |> 
    distinct() |> 
    group_by(NCBI_ID, Attribute) |> 
    slice_head(n = 1) |> 
    ungroup() |> 
    group_by(NCBI_ID) |>
    ## Attribute score per taxon must add up to 1
    mutate(
        Total_score = sum(Score),
        Score = Score / Total_score
    ) |>
    ungroup() |> 
    distinct()
w <- NULL
withCallingHandlers(
    warning = function(cnd) w <<- cnd,
    set_with_ids$Rank <- taxizedb::taxid2rank(set_with_ids$NCBI_ID, db = 'ncbi')
)
taxids_with_missing_rank <- unlist(
    strsplit(sub('^.*: (.*$)', '\\1', w$message), ', ')
)
no_longer_missing_ranks <- unlist(
    taxize::tax_rank(taxids_with_missing_rank, db = 'ncbi')
)

for (i in seq_along(no_longer_missing_ranks)) {
    pos <- set_with_ids$NCBI_ID == names(no_longer_missing_ranks)[i]
    set_with_ids$Rank[pos] <- no_longer_missing_ranks[i]
}
dim(set_with_ids)
```

We need to use taxonomic binning to the NCBI IDs for the parents of the
rows without taxid

```{r set2 for asr}
set_without_ids <- phys_data |> 
    filter(lgl_vct) |> 
    select(-NCBI_ID, -Taxon_name, -Frequency) |> 
    relocate(NCBI_ID = Parent_NCBI_ID) |> 
    distinct()

if (nrow(set_with_ids) > 0) {
    set_without_ids <- set_without_ids |> 
        filter(!NCBI_ID %in% unique(set_with_ids$NCBI_ID))
}
w2 <- NULL
withCallingHandlers(
    warning = function(cnd) w2 <<- cnd,
    set_without_ids$Rank <- taxizedb::taxid2rank(set_without_ids$NCBI_ID, db = 'ncbi')
)
taxids_with_missing_rank2 <- unlist(
    strsplit(sub('^.*: (.*$)', '\\1', w2$message), ', ')
)
no_longer_missing_ranks2 <- unlist(
    taxize::tax_rank(taxids_with_missing_rank2, db = 'ncbi')
)
for (i in seq_along(no_longer_missing_ranks2)) {
    pos2 <- set_without_ids$NCBI_ID == names(no_longer_missing_ranks2)[i]
    set_without_ids$Rank[pos2] <- no_longer_missing_ranks2[i]
}
dim(set_without_ids)
```

All attribute scores per taxon must add up to 1

```{r}
## 55565
set_without_ids <- set_without_ids |>    
    group_by(NCBI_ID, Attribute) |> 
    slice_head(n = 1) |> 
    ungroup() |> 
    group_by(NCBI_ID) |>
    mutate(
        ## All attribute scores per taxon must add up to 1
        Total_score = sum(Score),
        Score = Score / Total_score
    ) |>
    ungroup() |>
    distinct()
phys_data_ready <- left_join(set_with_ids, set_without_ids) |> 
    select(-Total_score, -Parent_NCBI_ID) |> 
    mutate(
        NCBI_ID = case_when(
            Rank == 'strain' ~ paste0('t__', NCBI_ID),
            Rank == 'species' ~ paste0('s__', NCBI_ID),
            Rank == 'genus' ~ paste0('g__', NCBI_ID)
        )
    ) |> 
    mutate(taxid = sub('^\\w__', '', NCBI_ID))
## Split in lists to use with the NCBI taxonoomic tree
phys_data_list <- split(phys_data_ready, factor(phys_data_ready$NCBI_ID))
length(phys_data_list)
```


## Tree data

### Taxonomic tree

```{r}
data('tree_list')
ncbi_tree <- as.Node(tree_list)
ncbi_tree_nodes <- unname(ncbi_tree$Get('name'))
print(ncbi_tree, limit = 10)
```

### Phylogenectic tree

```{r}
ltp <- ltp()
tree <- ltp$tree
tree
```

### Phylogenetic tree (tip data)

```{r}
tip_data <- ltp$tip_data
dim(tip_data)
```

### Some completeness stats

Annotations from sources than can be mapped to the NCBI tree:

```{r}
ncbi_tree_nodes_gst <- ncbi_tree_nodes[which(grepl('^[wst]__', ncbi_tree_nodes))]
mean(phys_data_ready$NCBI_ID %in% ncbi_tree_nodes_gst)
```

Proportion of NCBI tree nodes (gst) with annotations:

```{r}
mean(ncbi_tree_nodes_gst %in% phys_data_ready$NCBI_ID)
```

Annotations from sources than can me mapped to the phylogenetic tree tips:

```{r}
mean(phys_data_ready$taxid %in% tip_data$taxid)
```

Proportion of tips in the phylogenetic tree with annotations:

```{r}
mean(tip_data$taxid %in% phys_data_ready$taxid)
```

## Increase number of tips with annotations

### Map NCBI IDs to the NCBI taxonomic tree

At this point only genus, species, and strain annotations are present.

```{r}
ncbi_tree$Do(function(node) {
    if (node$name %in% names(phys_data_list)) {
        node$attribute_tbl <- phys_data_list[[node$name]]
    } else {
        NULL
    }
})
## An example (E. coli):
ncbi_tree$d__2$p__1224$c__1236$o__91347$f__543$g__561$s__562$attribute_tbl
```

```{r}
ncbi_attr_gst <- ncbi_tree$Get(
    'attribute_tbl', filterFun = function(node) grepl('^[gst]__', node$name)
)
mean(!map_lgl(ncbi_attr_gst, ~ all(is.na(.x))))
```

Removing annotations just to compare with result after propagation

```{r}
ncbi_tree$d__2$p__1224$c__1236$o__91347$f__543$g__561$attribute_tbl <- NULL
ncbi_tree$d__2$p__1224$c__1236$o__91347$f__543$g__561$attribute_tbl
```

Lest pool and normalize attribute scores at each taxonomic rank (gst) for
child taxa

```{r}
## ASR - post-order
taxPool <- function(node) {
    if (!node$isLeaf) {
        children_names <- names(node$children)
        attribute_tbls <- children_names |> 
            purrr::map(~ node[[.x]]$attribute_tbl) |>
            purrr::discard(is.null)
        not_all_children_tbls_are_null <- length(attribute_tbls) > 0
        node_attribute_tbl_is_null <- is.null(node$table)
        node_is_gst <- grepl('^[gst]__', node$name)
        conds <- node_attribute_tbl_is_null & 
            not_all_children_tbls_are_null &
            node_is_gst
        if (conds) {
            res_tbl <- purrr::discard(attribute_tbls, is.null) |>
                dplyr::bind_rows() |>
                dplyr::select(
                    NCBI_ID, Attribute, Score,
                    Attribute_type, Attribute_group
                ) |> 
                dplyr::mutate(
                    NCBI_ID = node$name,
                    Evidence = 'asr1'
                ) |>
                group_by(NCBI_ID) |>
                mutate(
                    Total_score = sum(Score),
                    Score = Score / Total_score
                ) |>
                ungroup() |>
                select(-Total_score) |> 
                group_by(NCBI_ID, Attribute) |> 
                mutate(Score = sum(Score)) |> 
                ungroup() |> 
                distinct() |> 
                mutate(
                    Frequency = case_when(
                        Score == 1 ~ 'always',
                        Score > 0.9 ~ 'usually',
                        Score >= 0.5 ~ 'sometimes',
                        Score > 0 & Score < 0.5 ~ 'rarely',
                        Score == 0 ~ 'never'
                    )
                ) |> 
                distinct()
                node[['attribute_tbl']] <- res_tbl
        } 
    }
}
ncbi_tree$Do(taxPool, traversal = 'post-order')
## Same E. coli example:
ncbi_tree$d__2$p__1224$c__1236$o__91347$f__543$g__561$attribute_tbl
```

How many nodes family and above with attribute table?

```{r}
ncbi_attr_kpcof <- ncbi_tree$Get(
    'attribute_tbl', filterFun = function(node) grepl('^[kpcor]__', node$name)
)
mean(!map_lgl(ncbi_attr_kpcof, ~ all(is.na(.x))))
```

How many nodes genus and below with attribute table?

```{r}
ncbi_attr_gst <- ncbi_tree$Get(
    'attribute_tbl', filterFun = function(node) grepl('^[gst]__', node$name)
)
## A slight increase 12 to 15%
mean(!map_lgl(ncbi_attr_gst, ~ all(is.na(.x))))
```


Child taxa of  E. coli with unobserved annotations can inherit these
values with a slight penalty:

```{r}
## Inheritance - pre-order
inh1 <- function(node,  adjF = 0.1) {
    if (node$isRoot)
        return(NULL)
    if (is.null(node$parent$attribute_tbl))
        return(NULL)
    if (is.null(node$attribute_tbl) && grepl('^[st]__', node$name)) {
        df <- node$parent$attribute_tbl
        n <- nrow(df)
        df <- df |>
            dplyr::mutate(
                target_scores = rep(1 / n, n),
                score_diff = Score - target_scores,
                Score = Score - adjF * score_diff,
                NCBI_ID = node$name,
                Evidence = 'inh'
            )
        node$attribute_tbl <- df
    }
}
ncbi_tree$Do(inh1, traversal = 'pre-order')
```

Proportion of nodes at the family level and above with attributes:

```{r}
ncbi_attr_kpcof <- ncbi_tree$Get(
    'attribute_tbl', filterFun = function(node) grepl('^[kpcor]__', node$name)
)
mean(!map_lgl(ncbi_attr_kpcof, ~ all(is.na(.x))))
```

Proportion of nodes at the genus, species, and strain levels with attributes:

```{r}
ncbi_attr_gst <- ncbi_tree$Get(
    'attribute_tbl', filterFun = function(node) grepl('^[gst]__', node$name)
)
## Major increase 15 to 78%
mean(!map_lgl(ncbi_attr_gst, ~ all(is.na(.x))))
```

The step above actually covered must of the genus, species, and strains,
but this is one of the datasets with the most annotations, so it's expected
that most of the taxa would already be covered.

A formal ASR method would be nice, however.

Get new attributes:

```{r}
new_attributes <- ncbi_attr_gst |> 
    discard(~ all(is.na(.x))) |> 
    bind_rows() |> 
    arrange(NCBI_ID, Attribute) |> 
    filter(!NCBI_ID %in% phys_data_ready$NCBI_ID) |> 
    mutate(taxid = sub('^\\w__', '', NCBI_ID)) |> 
    bind_rows(phys_data_ready)
table(new_attributes$Evidence)
```

Now almost 80% of the tips have annoations:

```{r}
mean(tip_data$taxid %in% new_attributes$taxid)
```

```{r}
new_tip_data <- left_join(tip_data, new_attributes, by = 'taxid')  
table(new_tip_data$Evidence, useNA = 'always')
```


Let's create an input matrix for ASR with the phylogenetic tree

```{r}
m1 <- new_tip_data |> 
    select(tip_label, Attribute, Score) |> 
    filter(!is.na(Attribute)) |> 
    # complete(NCB_ID, Attribute, fill = list(Score = 0)) |> 
    pivot_wider(
        names_from = 'Attribute', values_from = 'Score'
    )
    # tibble::column_to_rownames(var = 'tip_label') |> 
    # as.matrix()

no_annotated_tips <- tip |>
    filter(!tip_label %in% rownames(m1)) |>
    pull(tip_label)

m2 <- matrix(
    data = rep(rep(1/ncol(m1), ncol(m1)), length(no_annotated_tips)),
    nrow = length((no_annotated_tips)),
    byrow = TRUE,
    dimnames = list(rownames = no_annotated_tips, colnames = colnames(m1))
)

m3 <- rbind(m1, m2)
m3 <- m3[mpa_tree$tip.label,]
dim(m3)
```

```{r}
ultra <- chronoMPL(mpa_tree)
set.seed(4390)
new_tree <- dispRity::remove.zero.brlen(mpa_tree)
system.time(
    fit <- fitMk(
        tree = new_tree, 
        x = m3, 
        model = 'ER', 
        pi = "fitzjohn", 
        logscale = TRUE, 
        lik.func = "pruning"
    )
)
## A few seconds or minutes with fitMK.parellel
```

```{r}
system.time(
    # ace <- ancr(fit, type = 'marginal', tips = TRUE) 
    ace <- ancr(fit, type = 'marginal') # don't include tips
)
```


```{r}
node_data <- as_tibble(modify(ltp('nodes'), as.character))
res <- ace$ace
rownames(res) <- mpa_tree$node.label
res <- res |> 
    as.data.frame() |> 
    tibble::rownames_to_column(var = 'node_label') |> 
    left_join(node_data, by = 'node_label') |> 
    as_tibble() |> 
    filter(!is.na(taxid))
dim(res)
```


```{r}
## It seems that at least half of the nodes would have new annotations,
## which I think it's ok, since this should be the nodes of higher
## ranks in the taxonomic tree
mean(!res$taxid %in% new_data$taxid)
```


```{r}
data_for_inh2 <- filter(res, !taxid %in% new_data$taxid)
dim(data_for_inh2)
```


```{r}
input_for_inh2 <- data_for_inh2 |> 
    select(-ends_with('_taxid'), -node_label, -node, -n_labels) |> 
    relocate(NCBI_ID = taxid) |>
    pivot_longer(
        names_to = 'Attribute', values_to = 'Score', cols = 2:last_col()
    ) |> 
    complete(Attribute, Score, fill = list(Score = 0)) |> 
    relocate(NCBI_ID) |> 
    arrange(NCBI_ID, Attribute) |> 
    mutate(Evidence = 'asr2') |> 
    {\(y) split(y, factor(y$NCBI_ID))}()
length(input_for_inh2)
```

Add more nodes

```{r}
data_tree$Do(function(node) {
    cond1 <- is.null(node$attribute_tbl)
    taxid <- sub('^\\w__', '', node$name)
    cond2 <- taxid %in% names(input_for_inh2)
    if (cond1 && cond2) {
        # message('Adding ', node$name, ' to the tree')
        node$attribute_tbl <- input_for_inh2[[taxid]]
    }
})
data_tree$d__2$attribute_tbl
```

Now, let's proceed to inheritance (this time let's add a penalty)

```{r}
inh2 <- function(node, adjF = 0.1) {
    cond1 <- !node$isRoot # don't apply this to the root
    cond2 <- is.null(node$attribute_tbl) # attribute_tbl must be empty
    cond3 <- !is.null(node$parent$attribute_tbl) # parent must have data
    if (cond1 && cond2 && cond3) {
        # message('Adding ', node$name, '.')
        tbl <- node$parent$attribute_tbl  
        n <- nrow(tbl)
        res <- tbl |> 
            mutate(
                target_scores = rep(1 / n, n),
                score_diff = Score - target_scores,
                Score = Score - adjF * score_diff,
                NCBI_ID = node$name,
                Evidence = 'inh2'
            ) |>
            select(-target_scores, -score_diff) |> 
            relocate(NCBI_ID)
        node$attribute_tbl <- res
    }
}
data_tree$Do(inh2, traversal = 'pre-order')
```


```{r}
data_tree$d__2$p__1224$c__28211$o__356$f__335928$attribute_tbl
```

Get all the tables

```{r}
output <- data_tree$Get(
    attribute = 'attribute_tbl', simplify = FALSE,
    filterFun = function(node) node$name != 'ArcBac'
    )
output <- bind_rows(output)
head(output)
```

## Session information

```{r}
sessioninfo::session_info()
```

