---
title: "A propagation workflow with taxonomic pooling, asr (phytools), and inhertiance"
output:
    html_document:
        toc: true
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, message=FALSE}
library(bugphyzz)
library(taxPPro)
library(data.tree)
library(phytools)
library(dplyr)
library(purrr)
library(tidyr)
library(ggplot2)
```

## Import physiology data

```{r import physiology, message=FALSE}
phys_name <- 'aerophilicity'
phys <- physiologies(phys_name)
```

## Filter data

```{r filter data}
select_cols <- c(
    'NCBI_ID', 'Taxon_name', 'Parent_NCBI_ID',
    'Attribute','Attribute_source', 'Confidence_in_curation',
    'Frequency', 'Score', 'Evidence', 
    'Attribute_type', 'Attribute_group'
)
valid_ranks <- c('genus', 'species', 'strain')
attributes_fname <- system.file(
    'extdata', 'attributes.tsv', package = 'bugphyzz'
)
attributes <- read.table(attributes_fname, sep = '\t', header = TRUE)
valid_attributes <- attributes |> 
    filter(attribute_group == phys_name) |> 
    pull(attribute) |> 
    unique()
phys_data <- phys[[1]] |> 
    as_tibble() |> 
    filter(Attribute_value == TRUE) |>
    filter(Attribute %in% valid_attributes) |> 
    filter(
        !((is.na(NCBI_ID) | NCBI_ID == 'unknown') & is.na(Parent_NCBI_ID))
    ) |> 
    filter(!is.na('Attribute_source'), !is.na('Frequency')) |>
    mutate(Score = freq2Scores(Frequency)) |> 
    select(all_of(select_cols)) |> 
    distinct()
n_dropped_rows <- nrow(phys[[1]]) - nrow(phys_data)
message(format(n_dropped_rows, big.mark = ','), ' rows were dropped.')
```

Some variables that I need

```{r}
Attribute_group_var <- unique(phys_data$Attribute_group)
Attribute_group_var
```

```{r}
Attribute_type_var <- unique(phys_data$Attribute_type)
Attribute_type_var
```

```{r}
ordered_colnames <- c(
    'NCBI_ID', 'Taxon_name', 'Rank',
    'Attribute', 'Attribute_source', 'Confidence_in_curation',
    'Evidence', 'Frequency', 'Score',
    'Attribute_group', 'Attribute_type',
    'taxid'
)
```

## Taxonomic pooling for taxa without NCBI_ID (taxid)

Divide data in two sets between taxa with or without NCBI_ID:

```{r}
lgl_vct <- is.na(phys_data$NCBI_ID) | phys_data$NCBI_ID == 'unknown'
set_with_ids <- phys_data |> 
    filter(!lgl_vct) |> 
    mutate(Rank = taxizedb::taxid2rank(NCBI_ID, db = 'ncbi')) |> 
    filter(Rank %in% valid_ranks) |> 
    mutate(Taxon_name = taxizedb::taxid2name(NCBI_ID, db = 'ncbi')) |>
    distinct() |> 
    mutate(Confidence_in_curation =  conf2Fct(Confidence_in_curation)) |> 
    group_by(NCBI_ID) |> 
    slice_max(Confidence_in_curation, n = 1, with_ties = TRUE) |> 
    ungroup() |> 
    group_by(NCBI_ID, Attribute) |> 
    slice_max(Attribute_source, n = 1, with_ties = FALSE) |> 
    ungroup() |> 
    group_by(NCBI_ID) |>
    mutate(Total_score = sum(Score), Score = Score / Total_score) |>
    ungroup() |> 
    mutate(Frequency = scores2Freq(Score)) |>
    select(-Parent_NCBI_ID, -Total_score) |> 
    mutate(taxid = NCBI_ID) |> 
    mutate(NCBI_ID = addRankPrefix(NCBI_ID, Rank)) |> 
    filter(!is.na(NCBI_ID)) |>
    distinct() |> 
    arrange(NCBI_ID, Attribute) |> 
    relocate(all_of(ordered_colnames))
dim(set_with_ids)
```

Get attribute annotations and scores for taxa without NCBI_ID from sources:

```{r}
set_without_ids <- phys_data |> 
    filter(lgl_vct) |> 
    select(
        -NCBI_ID, -Taxon_name, -Frequency
    ) |> 
    relocate(NCBI_ID = Parent_NCBI_ID) |> 
    mutate(Rank = taxizedb::taxid2rank(NCBI_ID, db = 'ncbi')) |> 
    filter(Rank %in% valid_ranks) |> 
    mutate(Taxon_name = taxizedb::taxid2name(NCBI_ID, db = 'ncbi')) |> 
    distinct() |> 
    mutate(Confidence_in_curation =  conf2Fct(Confidence_in_curation)) |>
    group_by(NCBI_ID) |>
    slice_max(Confidence_in_curation, n = 1, with_ties = TRUE) |>
    ungroup() |>
    group_by(NCBI_ID, Attribute) |>
    slice_max(Attribute_source, n = 1, with_ties = FALSE) |>
    ungroup() |>
    group_by(NCBI_ID) |>
    mutate(Total_score = sum(Score), Score = Score / Total_score
    ) |>
    mutate(Frequency = scores2Freq(Score)) |> 
    mutate(
        Evidence = 'tax',
        Attribute_group = Attribute_group_var,
        Attribute_type = Attribute_type_var,
        Attribute_source = NA,
        Confidence_in_curation = NA
    ) |> 
    ungroup() |>
    select(-Total_score) |> 
    mutate(taxid = NCBI_ID) |> 
    mutate(NCBI_ID = addRankPrefix(NCBI_ID, Rank)) |> 
    filter(!is.na(NCBI_ID)) |>
    filter(!NCBI_ID %in% unique(set_with_ids$NCBI_ID)) |> 
    distinct() |> 
    arrange(NCBI_ID, Attribute) |> 
    relocate(all_of(ordered_colnames))
dim(set_without_ids)
```

```{r}
phys_data_ready <- bind_rows(set_with_ids, set_without_ids) |> 
    complete(NCBI_ID, Attribute, fill = list(Score = 0)) |> 
    arrange(NCBI_ID, Attribute)
phys_data_list <- split(phys_data_ready, factor(phys_data_ready$NCBI_ID))
length(phys_data_list)
```

## Tree data

### Taxonomic tree 

```{r}
data('tree_list')
ncbi_tree <- as.Node(tree_list)
ncbi_tree_nodes <- unname(ncbi_tree$Get('name'))
class(ncbi_tree)
```

### Phylogenectic tree

```{r}
ltp <- ltp()
tree <- ltp$tree
tree
```

### Phylogenetic tree

```{r}
tip_data <- ltp$tip_data
dim(tip_data)
```

### Some completeness stats

Annotations from sources than can be mapped to the NCBI tree:

```{r}
ncbi_tree_nodes_gst <- ncbi_tree_nodes[which(grepl('^[gst]__', ncbi_tree_nodes))]
mean(phys_data_ready$NCBI_ID %in% ncbi_tree_nodes_gst)
```

Proportion of NCBI tree nodes (gst) with annotations:

```{r}
mean(ncbi_tree_nodes_gst %in% phys_data_ready$NCBI_ID)
```

Annotations from sources than can me mapped to the phylogenetic tree tips:

```{r}
mean(phys_data_ready$taxid %in% tip_data$taxid)
```

Proportion of tips in the phylogenetic tree with annotations:

```{r}
mean(tip_data$taxid %in% phys_data_ready$taxid)
```

## Increase number of tips with annotations

### Map NCBI IDs to the NCBI taxonomic tree

```{r}
ncbi_tree$Do(function(node) {
    if (node$name %in% names(phys_data_list)) {
        node$attribute_tbl <- phys_data_list[[node$name]]
    } else {
        node$attribute_tbl <- NULL
    }
})
## An example (E. coli):
ncbi_tree$k__2$p__1224$c__1236$o__91347$f__543$g__561$s__562$attribute_tbl
```

```{r}
ncbi_attr_gst <- ncbi_tree$Get(
    'attribute_tbl', filterFun = function(node) grepl('^[gst]__', node$name)
)
mean(!map_lgl(ncbi_attr_gst, ~ all(is.na(.x))))
```

Removing annotations just to compare with result after taxonomic pooling 

```{r}
ncbi_tree$k__2$p__1224$c__1236$o__91347$f__543$g__561$attribute_tbl <- NULL
ncbi_tree$k__2$p__1224$c__1236$o__91347$f__543$g__561$attribute_tbl
```

Lest pool and normalize attribute scores at each taxonomic rank (gst) for
child taxa

```{r}
## ASR - post-order
taxPool <- function(node) {
    if (!node$isLeaf) {
        children_names <- names(node$children)
        attribute_tbls <- children_names |> 
            purrr::map(~ node[[.x]]$attribute_tbl) |>
            purrr::discard(is.null)
        not_all_children_tbls_are_null <- length(attribute_tbls) > 0
        node_attribute_tbl_is_null <- is.null(node$table)
        node_is_gst <- grepl('^[gst]__', node$name)
        conds <- node_attribute_tbl_is_null & 
            not_all_children_tbls_are_null &
            node_is_gst
        if (conds) {
            res_tbl <- attribute_tbls |> 
                purrr::discard(is.null) |>
                dplyr::bind_rows() |>
                dplyr::select(
                    NCBI_ID, Attribute, Score
                ) |> 
                dplyr::mutate(
                    NCBI_ID = node$name,
                    taxid = node$taxid,
                    Taxon_name = node$Taxon_name,
                    Rank = node$Rank,
                    Evidence = 'tax',
                    Attribute_group = Attribute_group_var,
                    Attribute_type = Attribute_type_var
                ) |>
                group_by(NCBI_ID) |>
                mutate(
                    Total_score = sum(Score),
                    Score = Score / Total_score
                ) |>
                ungroup() |>
                select(-Total_score) |> 
                group_by(NCBI_ID, Attribute) |> 
                mutate(Score = sum(Score)) |> 
                ungroup() |> 
                distinct() |> 
                mutate(
                    Frequency = case_when(
                        Score == 1 ~ 'always',
                        Score > 0.9 ~ 'usually',
                        Score >= 0.5 ~ 'sometimes',
                        Score > 0 & Score < 0.5 ~ 'rarely',
                        Score == 0 ~ 'never'
                    )
                ) |> 
                mutate(
                    Attribute_source = NA,
                    Confidence_in_curation = NA
                ) |> 
                distinct()
                node[['attribute_tbl']] <- res_tbl
        } 
    }
}
ncbi_tree$Do(taxPool, traversal = 'post-order')
## Same E. coli example:
ncbi_tree$k__2$p__1224$c__1236$o__91347$f__543$g__561$attribute_tbl
```

How many nodes family and above with attribute table? (it should be zero)

```{r}
ncbi_attr_kpcof <- ncbi_tree$Get(
    'attribute_tbl', filterFun = function(node) grepl('^[dpcor]__', node$name)
)
mean(!map_lgl(ncbi_attr_kpcof, ~ all(is.na(.x))))
```

How many nodes genus and below with attribute table?

```{r}
ncbi_attr_gst <- ncbi_tree$Get(
    'attribute_tbl', filterFun = function(node) grepl('^[gst]__', node$name)
)
## A slight increase 12 to 15%
mean(!map_lgl(ncbi_attr_gst, ~ all(is.na(.x))))
```


Child taxa of  E. coli with unobserved annotations can inherit these
values with a slight penalty:

```{r}
## Inheritance - pre-order
inh1 <- function(node,  adjF = 0.1) {
    if (node$isRoot)
        return(NULL)
    if (is.null(node$parent$attribute_tbl))
        return(NULL)
    if (is.null(node$attribute_tbl) && grepl('^[st]__', node$name)) {
        df <- node$parent$attribute_tbl
        n <- nrow(df)
        df <- df |>
            dplyr::mutate(
                target_scores = rep(1 / n, n),
                score_diff = Score - target_scores,
                Score = Score - adjF * score_diff,
                NCBI_ID = node$name,
                Evidence = 'inh',
                Taxon_name = node$Taxon_name,
                Rank = node$Rank,
                taxid = node$taxid,
            ) |> 
            dplyr::select(-target_scores, -score_diff)
        node$attribute_tbl <- df
    }
}
ncbi_tree$Do(inh1, traversal = 'pre-order')
```


Let's look at one example of inheritance

```{r}
inh_nodes1 <- ncbi_tree$Get(
    'attribute_tbl', 
    simplify = FALSE,
    filterFun = function(node) {
        if (!is.null(node$attribute_tbl)) {
            return('inh' %in% unique(node$attribute_tbl$Evidence))
        } else {
            return(FALSE)
        }
})
inh_nodes1_subset <- inh_nodes1[map_int(inh_nodes1, nrow) > 1]
inh_nodes1_subset[['s__2588497']]
```

```{r}
parent1 <- ncbi_tree$Get(
    'attribute_tbl', 
    simplify = FALSE,
    filterFun = function(node) {
        node$name == 'g__1344552'
    })
parent1[[1]]
```


Proportion of nodes at the family level and above with attributes (it should be zero):

```{r}
ncbi_attr_kpcof <- ncbi_tree$Get(
    'attribute_tbl', filterFun = function(node) grepl('^[kpcor]__', node$name)
)
mean(!map_lgl(ncbi_attr_kpcof, ~ all(is.na(.x))))
```

Proportion of nodes at the genus, species, and strain levels with attributes:

```{r}
ncbi_attr_gst <- ncbi_tree$Get(
    'attribute_tbl', filterFun = function(node) grepl('^[gst]__', node$name)
)
## Major increase 15 to 78%
mean(!map_lgl(ncbi_attr_gst, ~ all(is.na(.x))))
```

The step above actually covered must of the genus, species, and strains,
but this is one of the datasets with the most annotations, so it's expected
that most of the taxa would already be covered.

A formal ASR method would be nice, however.

Get new attributes:

```{r}
new_attributes <- ncbi_attr_gst |> 
    discard(~ all(is.na(.x))) |> 
    bind_rows() |> 
    arrange(NCBI_ID, Attribute) |> 
    filter(!NCBI_ID %in% phys_data_ready$NCBI_ID) |> 
    mutate(taxid = sub('^\\w__', '', NCBI_ID)) |> 
    bind_rows(phys_data_ready)
table(new_attributes$Evidence)
```

Now almost 90% of the tips have annotations:

```{r}
mean(tip_data$taxid %in% new_attributes$taxid)
```

```{r}
new_tip_data <- left_join(tip_data, new_attributes, by = 'taxid')  
table(new_tip_data$Evidence, useNA = 'always')
```

Let's create an input matrix for ASR with the phylogenetic tree

```{r}
new_tip_data_completed <- new_tip_data |> 
    select(tip_label, Attribute, Score) |> 
    filter(!is.na(Attribute)) |> 
    complete(tip_label, Attribute, fill = list(Score = 0))
m1 <- new_tip_data_completed |> 
    # select(tip_label, Attribute, Score) |> 
    # filter(!is.na(Attribute)) |> 
    # complete(tip_label, Attribute, fill = list(Score = 0)) |>
    pivot_wider(
        names_from = 'Attribute', values_from = 'Score'
    ) |> 
    tibble::column_to_rownames(var = 'tip_label') |>
    as.matrix()

no_annotated_tips <- new_tip_data |>
    filter(!tip_label %in% rownames(m1)) |>
    pull(tip_label) |> 
    unique()

m2 <- matrix(
    data = rep(rep(1/ncol(m1), ncol(m1)), length(no_annotated_tips)),
    nrow = length((no_annotated_tips)),
    byrow = TRUE,
    dimnames = list(rownames = no_annotated_tips, colnames = colnames(m1))
)

m3 <- rbind(m1, m2)
m3 <- m3[tree$tip.label,]
dim(m3)
```

Histogram of probabilites for tips with annotations

```{r}
x <- m1
dim(x) <- NULL
data.frame(prob = x) |> 
    ggplot(aes(prob)) +
    geom_histogram(binwidth = 0.1) +
    ggtitle('Tips with annotations, all probabilities')
```

```{r}
y <- as.double(apply(m1, 1, max))
data.frame(prob = y) |> 
    ggplot(aes(prob)) +
    geom_histogram(binwidth = 0.1) +
    ggtitle('Tips with annotations, max probabilities')
```

```{r}
z <- m3
dim(z) <- NULL
data.frame(prob = z) |> 
    ggplot(aes(prob)) +
    geom_histogram(binwidth = 0.1) +
    ggtitle('All tips, all probabilities')
```

## ASR with phytools

```{r}
system.time({
    fit <- fitMk(
        tree = tree, x = m3, model = 'ER', pi = 'fitzjohn', 
        lik.func = 'pruning', logscale = TRUE
    )
    asr <- ancr(object = fit, tips = TRUE)
})
```


```{r}
res <- asr$ace
node_rows <- length(tree$tip.label) + 1:tree$Nnode
rownames(res)[node_rows] <- tree$node.label
```

Probabilities of internal nodes

```{r}
data.frame(prob = as.double(res[tree$node.label,])) |> 
    ggplot(aes(prob)) +
    geom_histogram(binwidth = 0.1) +
    ggtitle('Internal nodes, all probabilities')
```


Probabilities of tips

```{r}
data.frame(prob = as.double(res[tree$tip.label,])) |> 
    ggplot(aes(prob)) +
    geom_histogram(binwidth = 0.1) +
    ggtitle('Tips, all probabilities (after ASR)')

```


```{r}
maxRes <- unlist(apply(res, 1, max))
data.frame(prob = maxRes[tree$node.label]) |> 
    ggplot(aes(prob)) +
    geom_histogram(binwidth = 0.1) +
    ggtitle('Internal nodes, max probabilities')
```

```{r}
data.frame(prob = maxRes[rownames(m2)]) |> 
    ggplot(aes(prob)) +
    geom_histogram(binwidth = 0.1) +
    ggtitle('New tips, max probabilities')
```

```{r}
new_taxa_from_tips <- res[rownames(m2),] |> 
    as.data.frame() |> 
    tibble::rownames_to_column(var = 'tip_label') |> 
    left_join(tip_data, by = 'tip_label') |> 
    mutate(
        Rank = taxizedb::taxid2rank(taxid, db = 'ncbi')
    ) |> 
    filter(Rank %in% c('genus', 'species', 'strain')) |> 
    mutate(
        NCBI_ID = case_when(
            Rank == 'genus' ~ paste0('g__', taxid),
            Rank == 'species' ~ paste0('s__', taxid),
            Rank == 'strain' ~ paste0('t__', taxid)
        )
    ) |> 
    rename(Taxon_name = taxname) |> 
    select(-ends_with('_taxid'), -tip_label, -taxid, -accession) |> 
    relocate(NCBI_ID, Taxon_name, Rank) |> 
    pivot_longer(
        names_to = 'Attribute', values_to = 'Score', cols = 4:last_col()
    ) |> 
    mutate(
        Evidence = 'asr',
        Attribute_source = NA,
        Confidence_in_curation = NA,
        taxid = sub('\\w__', '', NCBI_ID),
        Attribute_type = Attribute_type_var,
        Attribute_group = Attribute_group_var,
        Frequency = case_when(
            Score == 1 ~ 'always',
            Score > 0.9 ~ 'usually',
            Score >= 0.5 ~ 'sometimes',
            Score > 0 & Score < 0.5 ~ 'rarely',
            Score == 0 ~ 'never'
        )
    )
head(new_taxa_from_tips)
```

Most of these new taxa are in the NCBI tree:

```{r}
ncbi_tree_nodes_empty <- ncbi_tree$Get(
    'attribute_tbl', filterFun = function(node) {
        is.null(node$attribute_tbl) || all(is.na(node$attribute_tbl))   
    }) |> 
    {\(y) names(y)}()
mean(new_taxa_from_tips$NCBI_ID %in% ncbi_tree_nodes_empty)
```

Let's check nodes

```{r}
nodes_annotated <- res[which(grepl('^\\d+(\\+\\d+)*', rownames(res))),]
new_taxa_from_nodes <- nodes_annotated |> 
    as.data.frame() |> 
    tibble::rownames_to_column(var = 'NCBI_ID') |> 
    mutate(NCBI_ID = strsplit(NCBI_ID, '\\+')) |> 
    tidyr::unnest(NCBI_ID) |> 
    mutate(Rank = taxizedb::taxid2rank(NCBI_ID)) |> 
    mutate(Rank = ifelse(Rank == 'superkingdom', 'kingdom', Rank)) |> 
    mutate(
        NCBI_ID = case_when(
            Rank == 'kingdom' ~ paste0('k__', NCBI_ID),
            Rank == 'phylum' ~ paste0('p__', NCBI_ID),
            Rank == 'class' ~ paste0('c__', NCBI_ID),
            Rank == 'order' ~ paste0('o__', NCBI_ID),
            Rank == 'family' ~ paste0('f__', NCBI_ID),
            Rank == 'genus' ~ paste0('g__', NCBI_ID),
            Rank == 'species' ~ paste0('s__', NCBI_ID),
            Rank == 'strain' ~ paste0('t__', NCBI_ID)
        )
    ) |> 
    filter(
        Rank %in% c(
            'kingdom', 'phylum', 'class', 'order', 'family', 'genus',
            'species', 'strain'
        )
    ) |> 
    mutate(Evidence = 'asr') |> 
    relocate(NCBI_ID, Rank, Evidence) |> 
    pivot_longer(
        cols = 4:last_col(), names_to = 'Attribute', values_to = 'Score'
    ) |> 
    mutate(
        Attribute_source = NA,
        Confidence_in_curation = NA,
        Attribute_group = Attribute_group_var,
        Attribute_type = Attribute_type_var,
        taxid = sub('\\w__', '', NCBI_ID),
        Taxon_name = taxizedb::taxid2name(taxid, db = 'ncbi'),
        Frequency = case_when(
            Score == 1 ~ 'always',
            Score > 0.9 ~ 'usually',
            Score >= 0.5 ~ 'sometimes',
            Score > 0 & Score < 0.5 ~ 'rarely',
            Score == 0 ~ 'never'
        )
    )
head(new_taxa_from_nodes)
```

Some new taxa can be added to the nodes with empty attribute table:

```{r}
mean(new_taxa_from_nodes$NCBI_ID %in% ncbi_tree_nodes_empty)
```

Actually most are already in the tree, but we got them through taxonomic
binning (genus, species, and strains)

```{r}
mean(new_taxa_from_nodes$NCBI_ID %in% ncbi_tree_nodes)
```


Prepare new taxa:

```{r}
new_taxa_for_ncbi_tree <- new_taxa_from_tips |> 
    # select(-Taxon_name) |> 
    relocate(NCBI_ID, Rank, Attribute, Score, Evidence) |> 
    bind_rows(new_taxa_from_nodes)
new_taxa_for_ncbi_tree_list <- split(
    new_taxa_for_ncbi_tree, factor(new_taxa_for_ncbi_tree$NCBI_ID)
)
```

Let's add some taxa to the tree:

```{r}
ncbi_tree$Do(function(node) {
    cond1 <- node$name %in% names(new_taxa_for_ncbi_tree_list)
    cond2 <- is.null(node$attribute_tbl) || all(is.na(node$attribute_tbl))
    if (cond1 && cond2) {
        node$attribute_tbl <- new_taxa_for_ncbi_tree_list[[node$name]]
    }
})
```

How many are empty after this:

```{r}
ncbi_tree_nodes_empty2 <- ncbi_tree$Get(
    'attribute_tbl', filterFun = function(node) {
        is.null(node$attribute_tbl) || all(is.na(node$attribute_tbl))   
    }) |> 
    {\(y) names(y)}()
length(ncbi_tree_nodes_empty2)
```

Inheritance one more time:

```{r}
inh2 <- function(node, adjF = 0.1) {
    cond1 <- !node$isRoot
    cond2 <- is.null(node$attribute_tbl)
    cond3 <- !is.null(node$parent$attribute_tbl)
    if (cond1 && cond2 && cond3) {
        tbl <- node$parent$attribute_tbl  
        n <- nrow(tbl)
        res <- tbl |> 
            mutate(
                target_scores = rep(1 / n, n),
                score_diff = Score - target_scores,
                Score = Score - adjF * score_diff,
                NCBI_ID = node$name,
                Evidence = 'inh2'
            ) |>
            select(-target_scores, -score_diff) |> 
            relocate(NCBI_ID) |> 
            mutate(
                Attribute_source = NA,
                Confidence_in_curation = NA,
                Attribute_group = Attribute_group_var,
                Attribute_type = Attribute_type_var,
                taxid = node$taxid,
                Taxon_name = node$Taxon_name,
                Rank = node$Rank,
                Frequency = case_when(
                    Score == 1 ~ 'always',
                    Score > 0.9 ~ 'usually',
                    Score >= 0.5 ~ 'sometimes',
                    Score > 0 & Score < 0.5 ~ 'rarely',
                    Score == 0 ~ 'never'
                )
            )
        node$attribute_tbl <- res
    }
}
ncbi_tree$Do(inh2, traversal = 'pre-order')
```

How many are empty after this:

```{r}
ncbi_tree_nodes_empty2 <- ncbi_tree$Get(
    'attribute_tbl', filterFun = function(node) {
        is.null(node$attribute_tbl) || all(is.na(node$attribute_tbl))   
    }) |> 
    {\(y) names(y)}()
## Only the root (ArcBac) remains empty
length(ncbi_tree_nodes_empty2)
```

```{r}
ncbi_tree$k__2$p__1224$c__28211$o__356$f__335928$attribute_tbl
```

Get all the tables

```{r}
output <- ncbi_tree$Get(
    attribute = 'attribute_tbl', simplify = FALSE,
    filterFun = function(node) node$name != 'ArcBac'
    )
output <- bind_rows(output)
head(output)
```

Number of annotations per evidence

```{r}
table(output$Evidence, useNA = 'always')
```


NAs are the one that were completed with tidyr::complete, so all of them
have score 0

```{r}
output |> 
    filter(is.na(Evidence)) |> 
    pull(Score) |> 
    unique()
```


Final annotations passing the min threshold (0.25 for aerophilicity)

```{r}
min_thr <- 1 / length(unique(phys_data_ready$Attribute))
addTaxa1 <- phys_data_ready |> 
    filter(!NCBI_ID %in% unique(output$NCBI_ID))
addTaxa2 <- new_taxa_for_ncbi_tree|> 
    filter(!NCBI_ID %in% unique(output$NCBI_ID))
final_output <- bind_rows(list(output, addTaxa1, addTaxa2)) |> 
    filter(Score > min_thr)
dim(final_output)
```

## Session information

```{r}
sessioninfo::session_info()
```
