---
title: "Uncertainty in tips for binary attributes when there are only 'TRUE' annotations"
output:
  html_document:
    toc: true
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(ape)
library(phytools)
library(dplyr)
library(tidyr)
```

A few attributes in bugphyzz only have 'TRUE' annotations.
Other attributes have both 'TRUE' and 'FALSE' annotations.

Tips that are uncertain could be treated as FALSE annotations (imputed data) or 
uncertain annotations with prior probabilities set to 0.5 for TRUE and 0.5 for
FALSE. In any case, ASR is not very reliable with any of these approaches,
especially when the percentage of tips with annotations is low.

```{r}
data('primate.tree')
data('primate.data')
tree <- primate.tree
data <- primate.data
data <- data[tree$tip.label,]
rownames(data) <- paste0('taxon', 1:nrow(data))
tree$tip.label <- paste0('taxon', 1:Ntip(tree))
original <- data |>
    tibble::rownames_to_column(var = 'Taxa') |>
    select(Taxa, Activity_pattern) |>
    mutate(Presence = 1) |>
    pivot_wider(
        names_from = 'Activity_pattern', values_from = 'Presence',

                values_fill = 0
    ) |>
    arrange(Taxa) |>
    tibble::column_to_rownames(var = 'Taxa') |>
    select(Diurnal) |> 
    mutate(
        not_diurnal = ifelse(Diurnal == 0, 1, 0)
    ) |> 
    as.matrix()
colnames(original) <- c('A--TRUE', 'A--FALSE')

myFun <- function(mat, per_uncertain = 0.1) {
    n_row <- nrow(mat)
    n <- round(n_row * per_uncertain)
    rows <- sample(x = 1:nrow(mat), size = n, replace = FALSE)
    mat[rows,] <- rep(1/ncol(mat), ncol(mat))
    mat
}
```

# No uncertainty
```{r}
fit <- fitMk(tree = tree, x = original,
              model = "ARD", pi = "fitzjohn",
              lik.func = "pruning", logscale = TRUE)
ace <- ancr(fit, tips=TRUE)
plot(ace, args.plotTree = list(direction="upwards"))
title(main = '0% uncertain tips', line = -1)
```

# Assigning 0.5 for TRUE and FALSE for annotations

This doesn't really work when all annotations are positive

## 99% uncertainty

In this case, a single annotation overrides all other annotations.
99% of tips are uncertain (0.5 TRUE and 0.5 FALSE).

```{r}
set.seed(1234) 
m99 <- myFun(original, 0.99)
m99 <- m99[tree$tip.label,]
fit99 <- fitMk(tree = tree, x = m99,
              model = "ARD", pi = "fitzjohn",
              lik.func = "pruning", logscale = TRUE)
ace99 <- ancr(fit99, tips=TRUE)
plot(ace99, args.plotTree = list(direction = "upwards"))
title(main = '99% uncertain tips', line = -1)
```

## 95% uncertainty

```{r}
set.seed(1234) ## with this seed all values are TRUE that is what I left it here
m95 <- myFun(original, 0.95)
m95 <- m95[tree$tip.label,]
fit95 <- fitMk(tree = tree, x = m95,
              model = "ARD", pi = "fitzjohn",
              lik.func = "pruning", logscale = TRUE)
ace95 <- ancr(fit95, tips=TRUE)
plot(ace95, args.plotTree = list(direction="upwards"))
title(main = '95% uncertain tips', line = -1)

```


## 25% uncertainty

```{r}
# set.seed(1234)
# m75 <- myFun(original, 0.75)
# m75 <- m75[tree$tip.label,]
pos1 <- sample(1:nrow(original), round(nrow(original) * 0.75), replace = FALSE)
pos0.5 <- (1:nrow(original))[!1:nrow(original) %in% pos1]
m25 <- original
m25[] <- 0.5
m25[pos1, 1] <- 1
m25[pos1, 2] <- 0
fit25 <- fitMk(tree = tree, x = m25,
              model = "ARD", pi = "fitzjohn",
              lik.func = "pruning", logscale = TRUE)
m25 <- ancr(fit25, tips=TRUE)
plot(m25, args.plotTree = list(direction = "upwards"))
title(main = '25% uncertain tips', line = -1)
```



# Imputed zeros

```{r}
myFun2 <- function(vct, per_ones = 0.1) {
    ones <- which(vct == 1)
    zeros <- which(vct == 0)
    perN <- round(per_ones * length(vct))
    
    if (perN == length(ones)) {
        new_vct <- vct
    } else if (perN < length(ones)) {
        keep_ones <- sample(ones, perN, replace = FALSE)
        new_vct <- rep(0, length(vct))
        new_vct[keep_ones] <- 1
    } else if (perN > length(ones)) {
        need_more <- perN - length(ones)
        new_ones <- sample(zeros, need_more, replace = FALSE)
        new_vct <- vct
        new_vct[new_ones] <- 1
    }
    return(new_vct)
}

```

## 95% imputed zeros

```{r}
x1 <- original
set.seed(12343)
x1[,1] <- myFun2(x1[,1], 0.05)
x1[,2] <- ifelse(x1[,1] == 1, 0, 1)

x1 <- x1[tree$tip.label,]
fit_x1 <- fitMk(tree = tree, x = x1,
              model = "ARD", pi = "fitzjohn",
              lik.func = "pruning", logscale = TRUE)
ace_x1 <- ancr(fit_x1, tips=TRUE)
plot(ace_x1, args.plotTree = list(direction="upwards"))
title(main = '95% imputed zeros A--FALSE', line = -1)
```

## 75% imputed zeros

```{r}
x2 <- original
set.seed(12343)
x2[,1] <- myFun2(x2[,1], 0.25)
x2[,2] <- ifelse(x2[,1] == 1, 0, 1)

x2 <- x2[tree$tip.label,]
fit_x2 <- fitMk(tree = tree, x = x2,
              model = "ARD", pi = "fitzjohn",
              lik.func = "pruning", logscale = TRUE)
ace_x2 <- ancr(fit_x2, tips=TRUE)
plot(ace_x2, args.plotTree = list(direction="upwards"))
title(main = '75% imputed zeros A--FALSE', line = -1)
```

## As currently implemented

Maybe just a few will have annotations above the threholds.
I don't think we should import FALSE values since they were all inputed.

```{r}
hist(
  ace_x2$ace[Ntip(tree) + 1:Nnode(tree), 1],
  main = 'Scores of internal nodes TRUE', xlab = 'Score'
  
)
```

# Session information

```{r}
sessioninfo::session_info()
```





